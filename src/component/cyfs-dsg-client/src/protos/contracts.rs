// This file is generated by rust-protobuf 2.27.1. Do not edit
// @generated

// https://github.com/rust-lang/rust-clippy/issues/702
#![allow(unknown_lints)]
#![allow(clippy::all)]

#![allow(unused_attributes)]
#![cfg_attr(rustfmt, rustfmt::skip)]

#![allow(box_pointers)]
#![allow(dead_code)]
#![allow(missing_docs)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(trivial_casts)]
#![allow(unused_imports)]
#![allow(unused_results)]
//! Generated file from `protos/contracts.proto`

/// Generated files are compatible only with the same version
/// of protobuf runtime.
// const _PROTOBUF_VERSION_CHECK: () = ::protobuf::VERSION_2_27_1;

#[derive(PartialEq,Clone,Default)]
pub struct CacheStorage {
    // message fields
    pub pub_cyfs: bool,
    // message oneof groups
    pub _pub_http: ::std::option::Option<CacheStorage_oneof__pub_http>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CacheStorage {
    fn default() -> &'a CacheStorage {
        <CacheStorage as ::protobuf::Message>::default_instance()
    }
}

#[derive(Clone,PartialEq,Debug)]
pub enum CacheStorage_oneof__pub_http {
    pub_http(::std::string::String),
}

impl CacheStorage {
    pub fn new() -> CacheStorage {
        ::std::default::Default::default()
    }

    // string pub_http = 1;


    pub fn get_pub_http(&self) -> &str {
        match self._pub_http {
            ::std::option::Option::Some(CacheStorage_oneof__pub_http::pub_http(ref v)) => v,
            _ => "",
        }
    }
    pub fn clear_pub_http(&mut self) {
        self._pub_http = ::std::option::Option::None;
    }

    pub fn has_pub_http(&self) -> bool {
        match self._pub_http {
            ::std::option::Option::Some(CacheStorage_oneof__pub_http::pub_http(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_pub_http(&mut self, v: ::std::string::String) {
        self._pub_http = ::std::option::Option::Some(CacheStorage_oneof__pub_http::pub_http(v))
    }

    // Mutable pointer to the field.
    pub fn mut_pub_http(&mut self) -> &mut ::std::string::String {
        if let ::std::option::Option::Some(CacheStorage_oneof__pub_http::pub_http(_)) = self._pub_http {
        } else {
            self._pub_http = ::std::option::Option::Some(CacheStorage_oneof__pub_http::pub_http(::std::string::String::new()));
        }
        match self._pub_http {
            ::std::option::Option::Some(CacheStorage_oneof__pub_http::pub_http(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_pub_http(&mut self) -> ::std::string::String {
        if self.has_pub_http() {
            match self._pub_http.take() {
                ::std::option::Option::Some(CacheStorage_oneof__pub_http::pub_http(v)) => v,
                _ => panic!(),
            }
        } else {
            ::std::string::String::new()
        }
    }

    // bool pub_cyfs = 2;


    pub fn get_pub_cyfs(&self) -> bool {
        self.pub_cyfs
    }
    pub fn clear_pub_cyfs(&mut self) {
        self.pub_cyfs = false;
    }

    // Param is passed by value, moved
    pub fn set_pub_cyfs(&mut self, v: bool) {
        self.pub_cyfs = v;
    }
}

impl ::protobuf::Message for CacheStorage {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self._pub_http = ::std::option::Option::Some(CacheStorage_oneof__pub_http::pub_http(is.read_string()?));
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.pub_cyfs = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.pub_cyfs != false {
            my_size += 2;
        }
        if let ::std::option::Option::Some(ref v) = self._pub_http {
            match v {
                &CacheStorage_oneof__pub_http::pub_http(ref v) => {
                    my_size += ::protobuf::rt::string_size(1, &v);
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.pub_cyfs != false {
            os.write_bool(2, self.pub_cyfs)?;
        }
        if let ::std::option::Option::Some(ref v) = self._pub_http {
            match v {
                &CacheStorage_oneof__pub_http::pub_http(ref v) => {
                    os.write_string(1, v)?;
                },
            };
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CacheStorage {
        CacheStorage::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_string_accessor::<_>(
                "pub_http",
                CacheStorage::has_pub_http,
                CacheStorage::get_pub_http,
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "pub_cyfs",
                |m: &CacheStorage| { &m.pub_cyfs },
                |m: &mut CacheStorage| { &mut m.pub_cyfs },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CacheStorage>(
                "CacheStorage",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CacheStorage {
        static instance: ::protobuf::rt::LazyV2<CacheStorage> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CacheStorage::new)
    }
}

impl ::protobuf::Clear for CacheStorage {
    fn clear(&mut self) {
        self._pub_http = ::std::option::Option::None;
        self.pub_cyfs = false;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CacheStorage {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CacheStorage {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct BackupStorage {
    // message fields
    pub reserved: u32,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a BackupStorage {
    fn default() -> &'a BackupStorage {
        <BackupStorage as ::protobuf::Message>::default_instance()
    }
}

impl BackupStorage {
    pub fn new() -> BackupStorage {
        ::std::default::Default::default()
    }

    // uint32 reserved = 1;


    pub fn get_reserved(&self) -> u32 {
        self.reserved
    }
    pub fn clear_reserved(&mut self) {
        self.reserved = 0;
    }

    // Param is passed by value, moved
    pub fn set_reserved(&mut self, v: u32) {
        self.reserved = v;
    }
}

impl ::protobuf::Message for BackupStorage {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.reserved = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.reserved != 0 {
            my_size += ::protobuf::rt::value_size(1, self.reserved, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.reserved != 0 {
            os.write_uint32(1, self.reserved)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> BackupStorage {
        BackupStorage::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "reserved",
                |m: &BackupStorage| { &m.reserved },
                |m: &mut BackupStorage| { &mut m.reserved },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<BackupStorage>(
                "BackupStorage",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static BackupStorage {
        static instance: ::protobuf::rt::LazyV2<BackupStorage> = ::protobuf::rt::LazyV2::INIT;
        instance.get(BackupStorage::new)
    }
}

impl ::protobuf::Clear for BackupStorage {
    fn clear(&mut self) {
        self.reserved = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for BackupStorage {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for BackupStorage {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ImmutableDataSource {
    // message fields
    pub chunks: ::protobuf::RepeatedField<::std::vec::Vec<u8>>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ImmutableDataSource {
    fn default() -> &'a ImmutableDataSource {
        <ImmutableDataSource as ::protobuf::Message>::default_instance()
    }
}

impl ImmutableDataSource {
    pub fn new() -> ImmutableDataSource {
        ::std::default::Default::default()
    }

    // repeated bytes chunks = 1;


    pub fn get_chunks(&self) -> &[::std::vec::Vec<u8>] {
        &self.chunks
    }
    pub fn clear_chunks(&mut self) {
        self.chunks.clear();
    }

    // Param is passed by value, moved
    pub fn set_chunks(&mut self, v: ::protobuf::RepeatedField<::std::vec::Vec<u8>>) {
        self.chunks = v;
    }

    // Mutable pointer to the field.
    pub fn mut_chunks(&mut self) -> &mut ::protobuf::RepeatedField<::std::vec::Vec<u8>> {
        &mut self.chunks
    }

    // Take field
    pub fn take_chunks(&mut self) -> ::protobuf::RepeatedField<::std::vec::Vec<u8>> {
        ::std::mem::replace(&mut self.chunks, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for ImmutableDataSource {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_bytes_into(wire_type, is, &mut self.chunks)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.chunks {
            my_size += ::protobuf::rt::bytes_size(1, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.chunks {
            os.write_bytes(1, &v)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ImmutableDataSource {
        ImmutableDataSource::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "chunks",
                |m: &ImmutableDataSource| { &m.chunks },
                |m: &mut ImmutableDataSource| { &mut m.chunks },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ImmutableDataSource>(
                "ImmutableDataSource",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ImmutableDataSource {
        static instance: ::protobuf::rt::LazyV2<ImmutableDataSource> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ImmutableDataSource::new)
    }
}

impl ::protobuf::Clear for ImmutableDataSource {
    fn clear(&mut self) {
        self.chunks.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ImmutableDataSource {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ImmutableDataSource {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ContractDesc {
    // message fields
    pub data_source_type: ContractDesc_DataSourceType,
    pub storage_type: ContractDesc_StorageType,
    pub miner: ::std::vec::Vec<u8>,
    pub start_at: u64,
    pub end_at: u64,
    pub witness: ::std::vec::Vec<u8>,
    // message oneof groups
    pub data_source: ::std::option::Option<ContractDesc_oneof_data_source>,
    pub storage: ::std::option::Option<ContractDesc_oneof_storage>,
    pub _witness_dec_id: ::std::option::Option<ContractDesc_oneof__witness_dec_id>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ContractDesc {
    fn default() -> &'a ContractDesc {
        <ContractDesc as ::protobuf::Message>::default_instance()
    }
}

#[derive(Clone,PartialEq,Debug)]
pub enum ContractDesc_oneof_data_source {
    immut_data_source(ImmutableDataSource),
    mut_data_source(u64),
}

#[derive(Clone,PartialEq,Debug)]
pub enum ContractDesc_oneof_storage {
    cache_storage(CacheStorage),
    backup_storage(BackupStorage),
}

#[derive(Clone,PartialEq,Debug)]
pub enum ContractDesc_oneof__witness_dec_id {
    witness_dec_id(::std::vec::Vec<u8>),
}

impl ContractDesc {
    pub fn new() -> ContractDesc {
        ::std::default::Default::default()
    }

    // .ContractDesc.DataSourceType data_source_type = 1;


    pub fn get_data_source_type(&self) -> ContractDesc_DataSourceType {
        self.data_source_type
    }
    pub fn clear_data_source_type(&mut self) {
        self.data_source_type = ContractDesc_DataSourceType::Immutable;
    }

    // Param is passed by value, moved
    pub fn set_data_source_type(&mut self, v: ContractDesc_DataSourceType) {
        self.data_source_type = v;
    }

    // .ImmutableDataSource immut_data_source = 2;


    pub fn get_immut_data_source(&self) -> &ImmutableDataSource {
        match self.data_source {
            ::std::option::Option::Some(ContractDesc_oneof_data_source::immut_data_source(ref v)) => v,
            _ => <ImmutableDataSource as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_immut_data_source(&mut self) {
        self.data_source = ::std::option::Option::None;
    }

    pub fn has_immut_data_source(&self) -> bool {
        match self.data_source {
            ::std::option::Option::Some(ContractDesc_oneof_data_source::immut_data_source(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_immut_data_source(&mut self, v: ImmutableDataSource) {
        self.data_source = ::std::option::Option::Some(ContractDesc_oneof_data_source::immut_data_source(v))
    }

    // Mutable pointer to the field.
    pub fn mut_immut_data_source(&mut self) -> &mut ImmutableDataSource {
        if let ::std::option::Option::Some(ContractDesc_oneof_data_source::immut_data_source(_)) = self.data_source {
        } else {
            self.data_source = ::std::option::Option::Some(ContractDesc_oneof_data_source::immut_data_source(ImmutableDataSource::new()));
        }
        match self.data_source {
            ::std::option::Option::Some(ContractDesc_oneof_data_source::immut_data_source(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_immut_data_source(&mut self) -> ImmutableDataSource {
        if self.has_immut_data_source() {
            match self.data_source.take() {
                ::std::option::Option::Some(ContractDesc_oneof_data_source::immut_data_source(v)) => v,
                _ => panic!(),
            }
        } else {
            ImmutableDataSource::new()
        }
    }

    // uint64 mut_data_source = 3;


    pub fn get_mut_data_source(&self) -> u64 {
        match self.data_source {
            ::std::option::Option::Some(ContractDesc_oneof_data_source::mut_data_source(v)) => v,
            _ => 0,
        }
    }
    pub fn clear_mut_data_source(&mut self) {
        self.data_source = ::std::option::Option::None;
    }

    pub fn has_mut_data_source(&self) -> bool {
        match self.data_source {
            ::std::option::Option::Some(ContractDesc_oneof_data_source::mut_data_source(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_mut_data_source(&mut self, v: u64) {
        self.data_source = ::std::option::Option::Some(ContractDesc_oneof_data_source::mut_data_source(v))
    }

    // .ContractDesc.StorageType storage_type = 4;


    pub fn get_storage_type(&self) -> ContractDesc_StorageType {
        self.storage_type
    }
    pub fn clear_storage_type(&mut self) {
        self.storage_type = ContractDesc_StorageType::Cache;
    }

    // Param is passed by value, moved
    pub fn set_storage_type(&mut self, v: ContractDesc_StorageType) {
        self.storage_type = v;
    }

    // .CacheStorage cache_storage = 5;


    pub fn get_cache_storage(&self) -> &CacheStorage {
        match self.storage {
            ::std::option::Option::Some(ContractDesc_oneof_storage::cache_storage(ref v)) => v,
            _ => <CacheStorage as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_cache_storage(&mut self) {
        self.storage = ::std::option::Option::None;
    }

    pub fn has_cache_storage(&self) -> bool {
        match self.storage {
            ::std::option::Option::Some(ContractDesc_oneof_storage::cache_storage(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_cache_storage(&mut self, v: CacheStorage) {
        self.storage = ::std::option::Option::Some(ContractDesc_oneof_storage::cache_storage(v))
    }

    // Mutable pointer to the field.
    pub fn mut_cache_storage(&mut self) -> &mut CacheStorage {
        if let ::std::option::Option::Some(ContractDesc_oneof_storage::cache_storage(_)) = self.storage {
        } else {
            self.storage = ::std::option::Option::Some(ContractDesc_oneof_storage::cache_storage(CacheStorage::new()));
        }
        match self.storage {
            ::std::option::Option::Some(ContractDesc_oneof_storage::cache_storage(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_cache_storage(&mut self) -> CacheStorage {
        if self.has_cache_storage() {
            match self.storage.take() {
                ::std::option::Option::Some(ContractDesc_oneof_storage::cache_storage(v)) => v,
                _ => panic!(),
            }
        } else {
            CacheStorage::new()
        }
    }

    // .BackupStorage backup_storage = 6;


    pub fn get_backup_storage(&self) -> &BackupStorage {
        match self.storage {
            ::std::option::Option::Some(ContractDesc_oneof_storage::backup_storage(ref v)) => v,
            _ => <BackupStorage as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_backup_storage(&mut self) {
        self.storage = ::std::option::Option::None;
    }

    pub fn has_backup_storage(&self) -> bool {
        match self.storage {
            ::std::option::Option::Some(ContractDesc_oneof_storage::backup_storage(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_backup_storage(&mut self, v: BackupStorage) {
        self.storage = ::std::option::Option::Some(ContractDesc_oneof_storage::backup_storage(v))
    }

    // Mutable pointer to the field.
    pub fn mut_backup_storage(&mut self) -> &mut BackupStorage {
        if let ::std::option::Option::Some(ContractDesc_oneof_storage::backup_storage(_)) = self.storage {
        } else {
            self.storage = ::std::option::Option::Some(ContractDesc_oneof_storage::backup_storage(BackupStorage::new()));
        }
        match self.storage {
            ::std::option::Option::Some(ContractDesc_oneof_storage::backup_storage(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_backup_storage(&mut self) -> BackupStorage {
        if self.has_backup_storage() {
            match self.storage.take() {
                ::std::option::Option::Some(ContractDesc_oneof_storage::backup_storage(v)) => v,
                _ => panic!(),
            }
        } else {
            BackupStorage::new()
        }
    }

    // bytes miner = 7;


    pub fn get_miner(&self) -> &[u8] {
        &self.miner
    }
    pub fn clear_miner(&mut self) {
        self.miner.clear();
    }

    // Param is passed by value, moved
    pub fn set_miner(&mut self, v: ::std::vec::Vec<u8>) {
        self.miner = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_miner(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.miner
    }

    // Take field
    pub fn take_miner(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.miner, ::std::vec::Vec::new())
    }

    // uint64 start_at = 8;


    pub fn get_start_at(&self) -> u64 {
        self.start_at
    }
    pub fn clear_start_at(&mut self) {
        self.start_at = 0;
    }

    // Param is passed by value, moved
    pub fn set_start_at(&mut self, v: u64) {
        self.start_at = v;
    }

    // uint64 end_at = 9;


    pub fn get_end_at(&self) -> u64 {
        self.end_at
    }
    pub fn clear_end_at(&mut self) {
        self.end_at = 0;
    }

    // Param is passed by value, moved
    pub fn set_end_at(&mut self, v: u64) {
        self.end_at = v;
    }

    // bytes witness = 10;


    pub fn get_witness(&self) -> &[u8] {
        &self.witness
    }
    pub fn clear_witness(&mut self) {
        self.witness.clear();
    }

    // Param is passed by value, moved
    pub fn set_witness(&mut self, v: ::std::vec::Vec<u8>) {
        self.witness = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_witness(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.witness
    }

    // Take field
    pub fn take_witness(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.witness, ::std::vec::Vec::new())
    }

    // bytes witness_dec_id = 11;


    pub fn get_witness_dec_id(&self) -> &[u8] {
        match self._witness_dec_id {
            ::std::option::Option::Some(ContractDesc_oneof__witness_dec_id::witness_dec_id(ref v)) => v,
            _ => &[],
        }
    }
    pub fn clear_witness_dec_id(&mut self) {
        self._witness_dec_id = ::std::option::Option::None;
    }

    pub fn has_witness_dec_id(&self) -> bool {
        match self._witness_dec_id {
            ::std::option::Option::Some(ContractDesc_oneof__witness_dec_id::witness_dec_id(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_witness_dec_id(&mut self, v: ::std::vec::Vec<u8>) {
        self._witness_dec_id = ::std::option::Option::Some(ContractDesc_oneof__witness_dec_id::witness_dec_id(v))
    }

    // Mutable pointer to the field.
    pub fn mut_witness_dec_id(&mut self) -> &mut ::std::vec::Vec<u8> {
        if let ::std::option::Option::Some(ContractDesc_oneof__witness_dec_id::witness_dec_id(_)) = self._witness_dec_id {
        } else {
            self._witness_dec_id = ::std::option::Option::Some(ContractDesc_oneof__witness_dec_id::witness_dec_id(::std::vec::Vec::new()));
        }
        match self._witness_dec_id {
            ::std::option::Option::Some(ContractDesc_oneof__witness_dec_id::witness_dec_id(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_witness_dec_id(&mut self) -> ::std::vec::Vec<u8> {
        if self.has_witness_dec_id() {
            match self._witness_dec_id.take() {
                ::std::option::Option::Some(ContractDesc_oneof__witness_dec_id::witness_dec_id(v)) => v,
                _ => panic!(),
            }
        } else {
            ::std::vec::Vec::new()
        }
    }
}

impl ::protobuf::Message for ContractDesc {
    fn is_initialized(&self) -> bool {
        if let Some(ContractDesc_oneof_data_source::immut_data_source(ref v)) = self.data_source {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(ContractDesc_oneof_storage::cache_storage(ref v)) = self.storage {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(ContractDesc_oneof_storage::backup_storage(ref v)) = self.storage {
            if !v.is_initialized() {
                return false;
            }
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.data_source_type, 1, &mut self.unknown_fields)?
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.data_source = ::std::option::Option::Some(ContractDesc_oneof_data_source::immut_data_source(is.read_message()?));
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.data_source = ::std::option::Option::Some(ContractDesc_oneof_data_source::mut_data_source(is.read_uint64()?));
                },
                4 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.storage_type, 4, &mut self.unknown_fields)?
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.storage = ::std::option::Option::Some(ContractDesc_oneof_storage::cache_storage(is.read_message()?));
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.storage = ::std::option::Option::Some(ContractDesc_oneof_storage::backup_storage(is.read_message()?));
                },
                7 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.miner)?;
                },
                8 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.start_at = tmp;
                },
                9 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.end_at = tmp;
                },
                10 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.witness)?;
                },
                11 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self._witness_dec_id = ::std::option::Option::Some(ContractDesc_oneof__witness_dec_id::witness_dec_id(is.read_bytes()?));
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.data_source_type != ContractDesc_DataSourceType::Immutable {
            my_size += ::protobuf::rt::enum_size(1, self.data_source_type);
        }
        if self.storage_type != ContractDesc_StorageType::Cache {
            my_size += ::protobuf::rt::enum_size(4, self.storage_type);
        }
        if !self.miner.is_empty() {
            my_size += ::protobuf::rt::bytes_size(7, &self.miner);
        }
        if self.start_at != 0 {
            my_size += ::protobuf::rt::value_size(8, self.start_at, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.end_at != 0 {
            my_size += ::protobuf::rt::value_size(9, self.end_at, ::protobuf::wire_format::WireTypeVarint);
        }
        if !self.witness.is_empty() {
            my_size += ::protobuf::rt::bytes_size(10, &self.witness);
        }
        if let ::std::option::Option::Some(ref v) = self.data_source {
            match v {
                &ContractDesc_oneof_data_source::immut_data_source(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &ContractDesc_oneof_data_source::mut_data_source(v) => {
                    my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
                },
            };
        }
        if let ::std::option::Option::Some(ref v) = self.storage {
            match v {
                &ContractDesc_oneof_storage::cache_storage(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &ContractDesc_oneof_storage::backup_storage(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
            };
        }
        if let ::std::option::Option::Some(ref v) = self._witness_dec_id {
            match v {
                &ContractDesc_oneof__witness_dec_id::witness_dec_id(ref v) => {
                    my_size += ::protobuf::rt::bytes_size(11, &v);
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.data_source_type != ContractDesc_DataSourceType::Immutable {
            os.write_enum(1, ::protobuf::ProtobufEnum::value(&self.data_source_type))?;
        }
        if self.storage_type != ContractDesc_StorageType::Cache {
            os.write_enum(4, ::protobuf::ProtobufEnum::value(&self.storage_type))?;
        }
        if !self.miner.is_empty() {
            os.write_bytes(7, &self.miner)?;
        }
        if self.start_at != 0 {
            os.write_uint64(8, self.start_at)?;
        }
        if self.end_at != 0 {
            os.write_uint64(9, self.end_at)?;
        }
        if !self.witness.is_empty() {
            os.write_bytes(10, &self.witness)?;
        }
        if let ::std::option::Option::Some(ref v) = self.data_source {
            match v {
                &ContractDesc_oneof_data_source::immut_data_source(ref v) => {
                    os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &ContractDesc_oneof_data_source::mut_data_source(v) => {
                    os.write_uint64(3, v)?;
                },
            };
        }
        if let ::std::option::Option::Some(ref v) = self.storage {
            match v {
                &ContractDesc_oneof_storage::cache_storage(ref v) => {
                    os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &ContractDesc_oneof_storage::backup_storage(ref v) => {
                    os.write_tag(6, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
            };
        }
        if let ::std::option::Option::Some(ref v) = self._witness_dec_id {
            match v {
                &ContractDesc_oneof__witness_dec_id::witness_dec_id(ref v) => {
                    os.write_bytes(11, v)?;
                },
            };
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ContractDesc {
        ContractDesc::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<ContractDesc_DataSourceType>>(
                "data_source_type",
                |m: &ContractDesc| { &m.data_source_type },
                |m: &mut ContractDesc| { &mut m.data_source_type },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, ImmutableDataSource>(
                "immut_data_source",
                ContractDesc::has_immut_data_source,
                ContractDesc::get_immut_data_source,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_u64_accessor::<_>(
                "mut_data_source",
                ContractDesc::has_mut_data_source,
                ContractDesc::get_mut_data_source,
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<ContractDesc_StorageType>>(
                "storage_type",
                |m: &ContractDesc| { &m.storage_type },
                |m: &mut ContractDesc| { &mut m.storage_type },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, CacheStorage>(
                "cache_storage",
                ContractDesc::has_cache_storage,
                ContractDesc::get_cache_storage,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, BackupStorage>(
                "backup_storage",
                ContractDesc::has_backup_storage,
                ContractDesc::get_backup_storage,
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "miner",
                |m: &ContractDesc| { &m.miner },
                |m: &mut ContractDesc| { &mut m.miner },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "start_at",
                |m: &ContractDesc| { &m.start_at },
                |m: &mut ContractDesc| { &mut m.start_at },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "end_at",
                |m: &ContractDesc| { &m.end_at },
                |m: &mut ContractDesc| { &mut m.end_at },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "witness",
                |m: &ContractDesc| { &m.witness },
                |m: &mut ContractDesc| { &mut m.witness },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_bytes_accessor::<_>(
                "witness_dec_id",
                ContractDesc::has_witness_dec_id,
                ContractDesc::get_witness_dec_id,
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ContractDesc>(
                "ContractDesc",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ContractDesc {
        static instance: ::protobuf::rt::LazyV2<ContractDesc> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ContractDesc::new)
    }
}

impl ::protobuf::Clear for ContractDesc {
    fn clear(&mut self) {
        self.data_source_type = ContractDesc_DataSourceType::Immutable;
        self.data_source = ::std::option::Option::None;
        self.data_source = ::std::option::Option::None;
        self.storage_type = ContractDesc_StorageType::Cache;
        self.storage = ::std::option::Option::None;
        self.storage = ::std::option::Option::None;
        self.miner.clear();
        self.start_at = 0;
        self.end_at = 0;
        self.witness.clear();
        self._witness_dec_id = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ContractDesc {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ContractDesc {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum ContractDesc_DataSourceType {
    Immutable = 0,
    Mutable = 1,
}

impl ::protobuf::ProtobufEnum for ContractDesc_DataSourceType {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<ContractDesc_DataSourceType> {
        match value {
            0 => ::std::option::Option::Some(ContractDesc_DataSourceType::Immutable),
            1 => ::std::option::Option::Some(ContractDesc_DataSourceType::Mutable),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [ContractDesc_DataSourceType] = &[
            ContractDesc_DataSourceType::Immutable,
            ContractDesc_DataSourceType::Mutable,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            ::protobuf::reflect::EnumDescriptor::new_pb_name::<ContractDesc_DataSourceType>("ContractDesc.DataSourceType", file_descriptor_proto())
        })
    }
}

impl ::std::marker::Copy for ContractDesc_DataSourceType {
}

impl ::std::default::Default for ContractDesc_DataSourceType {
    fn default() -> Self {
        ContractDesc_DataSourceType::Immutable
    }
}

impl ::protobuf::reflect::ProtobufValue for ContractDesc_DataSourceType {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum ContractDesc_StorageType {
    Cache = 0,
    Backup = 1,
}

impl ::protobuf::ProtobufEnum for ContractDesc_StorageType {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<ContractDesc_StorageType> {
        match value {
            0 => ::std::option::Option::Some(ContractDesc_StorageType::Cache),
            1 => ::std::option::Option::Some(ContractDesc_StorageType::Backup),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [ContractDesc_StorageType] = &[
            ContractDesc_StorageType::Cache,
            ContractDesc_StorageType::Backup,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            ::protobuf::reflect::EnumDescriptor::new_pb_name::<ContractDesc_StorageType>("ContractDesc.StorageType", file_descriptor_proto())
        })
    }
}

impl ::std::marker::Copy for ContractDesc_StorageType {
}

impl ::std::default::Default for ContractDesc_StorageType {
    fn default() -> Self {
        ContractDesc_StorageType::Cache
    }
}

impl ::protobuf::reflect::ProtobufValue for ContractDesc_StorageType {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct DataSourceChangedState {
    // message fields
    pub chunks: ::protobuf::RepeatedField<::std::vec::Vec<u8>>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a DataSourceChangedState {
    fn default() -> &'a DataSourceChangedState {
        <DataSourceChangedState as ::protobuf::Message>::default_instance()
    }
}

impl DataSourceChangedState {
    pub fn new() -> DataSourceChangedState {
        ::std::default::Default::default()
    }

    // repeated bytes chunks = 1;


    pub fn get_chunks(&self) -> &[::std::vec::Vec<u8>] {
        &self.chunks
    }
    pub fn clear_chunks(&mut self) {
        self.chunks.clear();
    }

    // Param is passed by value, moved
    pub fn set_chunks(&mut self, v: ::protobuf::RepeatedField<::std::vec::Vec<u8>>) {
        self.chunks = v;
    }

    // Mutable pointer to the field.
    pub fn mut_chunks(&mut self) -> &mut ::protobuf::RepeatedField<::std::vec::Vec<u8>> {
        &mut self.chunks
    }

    // Take field
    pub fn take_chunks(&mut self) -> ::protobuf::RepeatedField<::std::vec::Vec<u8>> {
        ::std::mem::replace(&mut self.chunks, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for DataSourceChangedState {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_bytes_into(wire_type, is, &mut self.chunks)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.chunks {
            my_size += ::protobuf::rt::bytes_size(1, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.chunks {
            os.write_bytes(1, &v)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> DataSourceChangedState {
        DataSourceChangedState::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "chunks",
                |m: &DataSourceChangedState| { &m.chunks },
                |m: &mut DataSourceChangedState| { &mut m.chunks },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<DataSourceChangedState>(
                "DataSourceChangedState",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static DataSourceChangedState {
        static instance: ::protobuf::rt::LazyV2<DataSourceChangedState> = ::protobuf::rt::LazyV2::INIT;
        instance.get(DataSourceChangedState::new)
    }
}

impl ::protobuf::Clear for DataSourceChangedState {
    fn clear(&mut self) {
        self.chunks.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for DataSourceChangedState {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DataSourceChangedState {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct DataSourcePreparedState {
    // message fields
    pub chunks: ::protobuf::RepeatedField<::std::vec::Vec<u8>>,
    pub data_source_stub: ::std::vec::Vec<u8>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a DataSourcePreparedState {
    fn default() -> &'a DataSourcePreparedState {
        <DataSourcePreparedState as ::protobuf::Message>::default_instance()
    }
}

impl DataSourcePreparedState {
    pub fn new() -> DataSourcePreparedState {
        ::std::default::Default::default()
    }

    // repeated bytes chunks = 1;


    pub fn get_chunks(&self) -> &[::std::vec::Vec<u8>] {
        &self.chunks
    }
    pub fn clear_chunks(&mut self) {
        self.chunks.clear();
    }

    // Param is passed by value, moved
    pub fn set_chunks(&mut self, v: ::protobuf::RepeatedField<::std::vec::Vec<u8>>) {
        self.chunks = v;
    }

    // Mutable pointer to the field.
    pub fn mut_chunks(&mut self) -> &mut ::protobuf::RepeatedField<::std::vec::Vec<u8>> {
        &mut self.chunks
    }

    // Take field
    pub fn take_chunks(&mut self) -> ::protobuf::RepeatedField<::std::vec::Vec<u8>> {
        ::std::mem::replace(&mut self.chunks, ::protobuf::RepeatedField::new())
    }

    // bytes data_source_stub = 2;


    pub fn get_data_source_stub(&self) -> &[u8] {
        &self.data_source_stub
    }
    pub fn clear_data_source_stub(&mut self) {
        self.data_source_stub.clear();
    }

    // Param is passed by value, moved
    pub fn set_data_source_stub(&mut self, v: ::std::vec::Vec<u8>) {
        self.data_source_stub = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_data_source_stub(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.data_source_stub
    }

    // Take field
    pub fn take_data_source_stub(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.data_source_stub, ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for DataSourcePreparedState {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_bytes_into(wire_type, is, &mut self.chunks)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.data_source_stub)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.chunks {
            my_size += ::protobuf::rt::bytes_size(1, &value);
        };
        if !self.data_source_stub.is_empty() {
            my_size += ::protobuf::rt::bytes_size(2, &self.data_source_stub);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.chunks {
            os.write_bytes(1, &v)?;
        };
        if !self.data_source_stub.is_empty() {
            os.write_bytes(2, &self.data_source_stub)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> DataSourcePreparedState {
        DataSourcePreparedState::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "chunks",
                |m: &DataSourcePreparedState| { &m.chunks },
                |m: &mut DataSourcePreparedState| { &mut m.chunks },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "data_source_stub",
                |m: &DataSourcePreparedState| { &m.data_source_stub },
                |m: &mut DataSourcePreparedState| { &mut m.data_source_stub },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<DataSourcePreparedState>(
                "DataSourcePreparedState",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static DataSourcePreparedState {
        static instance: ::protobuf::rt::LazyV2<DataSourcePreparedState> = ::protobuf::rt::LazyV2::INIT;
        instance.get(DataSourcePreparedState::new)
    }
}

impl ::protobuf::Clear for DataSourcePreparedState {
    fn clear(&mut self) {
        self.chunks.clear();
        self.data_source_stub.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for DataSourcePreparedState {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DataSourcePreparedState {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ContractState {
    // message fields
    pub state_type: ContractState_ContractStateType,
    // message oneof groups
    pub state: ::std::option::Option<ContractState_oneof_state>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ContractState {
    fn default() -> &'a ContractState {
        <ContractState as ::protobuf::Message>::default_instance()
    }
}

#[derive(Clone,PartialEq,Debug)]
pub enum ContractState_oneof_state {
    data_source_changed(DataSourceChangedState),
    data_source_prepared(DataSourcePreparedState),
}

impl ContractState {
    pub fn new() -> ContractState {
        ::std::default::Default::default()
    }

    // .ContractState.ContractStateType state_type = 1;


    pub fn get_state_type(&self) -> ContractState_ContractStateType {
        self.state_type
    }
    pub fn clear_state_type(&mut self) {
        self.state_type = ContractState_ContractStateType::Initial;
    }

    // Param is passed by value, moved
    pub fn set_state_type(&mut self, v: ContractState_ContractStateType) {
        self.state_type = v;
    }

    // .DataSourceChangedState data_source_changed = 2;


    pub fn get_data_source_changed(&self) -> &DataSourceChangedState {
        match self.state {
            ::std::option::Option::Some(ContractState_oneof_state::data_source_changed(ref v)) => v,
            _ => <DataSourceChangedState as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_data_source_changed(&mut self) {
        self.state = ::std::option::Option::None;
    }

    pub fn has_data_source_changed(&self) -> bool {
        match self.state {
            ::std::option::Option::Some(ContractState_oneof_state::data_source_changed(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_data_source_changed(&mut self, v: DataSourceChangedState) {
        self.state = ::std::option::Option::Some(ContractState_oneof_state::data_source_changed(v))
    }

    // Mutable pointer to the field.
    pub fn mut_data_source_changed(&mut self) -> &mut DataSourceChangedState {
        if let ::std::option::Option::Some(ContractState_oneof_state::data_source_changed(_)) = self.state {
        } else {
            self.state = ::std::option::Option::Some(ContractState_oneof_state::data_source_changed(DataSourceChangedState::new()));
        }
        match self.state {
            ::std::option::Option::Some(ContractState_oneof_state::data_source_changed(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_data_source_changed(&mut self) -> DataSourceChangedState {
        if self.has_data_source_changed() {
            match self.state.take() {
                ::std::option::Option::Some(ContractState_oneof_state::data_source_changed(v)) => v,
                _ => panic!(),
            }
        } else {
            DataSourceChangedState::new()
        }
    }

    // .DataSourcePreparedState data_source_prepared = 3;


    pub fn get_data_source_prepared(&self) -> &DataSourcePreparedState {
        match self.state {
            ::std::option::Option::Some(ContractState_oneof_state::data_source_prepared(ref v)) => v,
            _ => <DataSourcePreparedState as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_data_source_prepared(&mut self) {
        self.state = ::std::option::Option::None;
    }

    pub fn has_data_source_prepared(&self) -> bool {
        match self.state {
            ::std::option::Option::Some(ContractState_oneof_state::data_source_prepared(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_data_source_prepared(&mut self, v: DataSourcePreparedState) {
        self.state = ::std::option::Option::Some(ContractState_oneof_state::data_source_prepared(v))
    }

    // Mutable pointer to the field.
    pub fn mut_data_source_prepared(&mut self) -> &mut DataSourcePreparedState {
        if let ::std::option::Option::Some(ContractState_oneof_state::data_source_prepared(_)) = self.state {
        } else {
            self.state = ::std::option::Option::Some(ContractState_oneof_state::data_source_prepared(DataSourcePreparedState::new()));
        }
        match self.state {
            ::std::option::Option::Some(ContractState_oneof_state::data_source_prepared(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_data_source_prepared(&mut self) -> DataSourcePreparedState {
        if self.has_data_source_prepared() {
            match self.state.take() {
                ::std::option::Option::Some(ContractState_oneof_state::data_source_prepared(v)) => v,
                _ => panic!(),
            }
        } else {
            DataSourcePreparedState::new()
        }
    }
}

impl ::protobuf::Message for ContractState {
    fn is_initialized(&self) -> bool {
        if let Some(ContractState_oneof_state::data_source_changed(ref v)) = self.state {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(ContractState_oneof_state::data_source_prepared(ref v)) = self.state {
            if !v.is_initialized() {
                return false;
            }
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.state_type, 1, &mut self.unknown_fields)?
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.state = ::std::option::Option::Some(ContractState_oneof_state::data_source_changed(is.read_message()?));
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.state = ::std::option::Option::Some(ContractState_oneof_state::data_source_prepared(is.read_message()?));
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.state_type != ContractState_ContractStateType::Initial {
            my_size += ::protobuf::rt::enum_size(1, self.state_type);
        }
        if let ::std::option::Option::Some(ref v) = self.state {
            match v {
                &ContractState_oneof_state::data_source_changed(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &ContractState_oneof_state::data_source_prepared(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.state_type != ContractState_ContractStateType::Initial {
            os.write_enum(1, ::protobuf::ProtobufEnum::value(&self.state_type))?;
        }
        if let ::std::option::Option::Some(ref v) = self.state {
            match v {
                &ContractState_oneof_state::data_source_changed(ref v) => {
                    os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &ContractState_oneof_state::data_source_prepared(ref v) => {
                    os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
            };
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ContractState {
        ContractState::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<ContractState_ContractStateType>>(
                "state_type",
                |m: &ContractState| { &m.state_type },
                |m: &mut ContractState| { &mut m.state_type },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, DataSourceChangedState>(
                "data_source_changed",
                ContractState::has_data_source_changed,
                ContractState::get_data_source_changed,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, DataSourcePreparedState>(
                "data_source_prepared",
                ContractState::has_data_source_prepared,
                ContractState::get_data_source_prepared,
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ContractState>(
                "ContractState",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ContractState {
        static instance: ::protobuf::rt::LazyV2<ContractState> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ContractState::new)
    }
}

impl ::protobuf::Clear for ContractState {
    fn clear(&mut self) {
        self.state_type = ContractState_ContractStateType::Initial;
        self.state = ::std::option::Option::None;
        self.state = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ContractState {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ContractState {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum ContractState_ContractStateType {
    Initial = 0,
    DataSourceChanged = 1,
    DataSourcePrepared = 2,
    DataSourceSyncing = 3,
    DataSourceStored = 4,
    ContractExecuted = 5,
    ContractBroken = 6,
}

impl ::protobuf::ProtobufEnum for ContractState_ContractStateType {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<ContractState_ContractStateType> {
        match value {
            0 => ::std::option::Option::Some(ContractState_ContractStateType::Initial),
            1 => ::std::option::Option::Some(ContractState_ContractStateType::DataSourceChanged),
            2 => ::std::option::Option::Some(ContractState_ContractStateType::DataSourcePrepared),
            3 => ::std::option::Option::Some(ContractState_ContractStateType::DataSourceSyncing),
            4 => ::std::option::Option::Some(ContractState_ContractStateType::DataSourceStored),
            5 => ::std::option::Option::Some(ContractState_ContractStateType::ContractExecuted),
            6 => ::std::option::Option::Some(ContractState_ContractStateType::ContractBroken),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [ContractState_ContractStateType] = &[
            ContractState_ContractStateType::Initial,
            ContractState_ContractStateType::DataSourceChanged,
            ContractState_ContractStateType::DataSourcePrepared,
            ContractState_ContractStateType::DataSourceSyncing,
            ContractState_ContractStateType::DataSourceStored,
            ContractState_ContractStateType::ContractExecuted,
            ContractState_ContractStateType::ContractBroken,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            ::protobuf::reflect::EnumDescriptor::new_pb_name::<ContractState_ContractStateType>("ContractState.ContractStateType", file_descriptor_proto())
        })
    }
}

impl ::std::marker::Copy for ContractState_ContractStateType {
}

impl ::std::default::Default for ContractState_ContractStateType {
    fn default() -> Self {
        ContractState_ContractStateType::Initial
    }
}

impl ::protobuf::reflect::ProtobufValue for ContractState_ContractStateType {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ContractStateDesc {
    // message fields
    pub contract: ::std::vec::Vec<u8>,
    pub state: ::protobuf::SingularPtrField<ContractState>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ContractStateDesc {
    fn default() -> &'a ContractStateDesc {
        <ContractStateDesc as ::protobuf::Message>::default_instance()
    }
}

impl ContractStateDesc {
    pub fn new() -> ContractStateDesc {
        ::std::default::Default::default()
    }

    // bytes contract = 1;


    pub fn get_contract(&self) -> &[u8] {
        &self.contract
    }
    pub fn clear_contract(&mut self) {
        self.contract.clear();
    }

    // Param is passed by value, moved
    pub fn set_contract(&mut self, v: ::std::vec::Vec<u8>) {
        self.contract = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_contract(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.contract
    }

    // Take field
    pub fn take_contract(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.contract, ::std::vec::Vec::new())
    }

    // .ContractState state = 2;


    pub fn get_state(&self) -> &ContractState {
        self.state.as_ref().unwrap_or_else(|| <ContractState as ::protobuf::Message>::default_instance())
    }
    pub fn clear_state(&mut self) {
        self.state.clear();
    }

    pub fn has_state(&self) -> bool {
        self.state.is_some()
    }

    // Param is passed by value, moved
    pub fn set_state(&mut self, v: ContractState) {
        self.state = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_state(&mut self) -> &mut ContractState {
        if self.state.is_none() {
            self.state.set_default();
        }
        self.state.as_mut().unwrap()
    }

    // Take field
    pub fn take_state(&mut self) -> ContractState {
        self.state.take().unwrap_or_else(|| ContractState::new())
    }
}

impl ::protobuf::Message for ContractStateDesc {
    fn is_initialized(&self) -> bool {
        for v in &self.state {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.contract)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.state)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.contract.is_empty() {
            my_size += ::protobuf::rt::bytes_size(1, &self.contract);
        }
        if let Some(ref v) = self.state.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.contract.is_empty() {
            os.write_bytes(1, &self.contract)?;
        }
        if let Some(ref v) = self.state.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ContractStateDesc {
        ContractStateDesc::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "contract",
                |m: &ContractStateDesc| { &m.contract },
                |m: &mut ContractStateDesc| { &mut m.contract },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ContractState>>(
                "state",
                |m: &ContractStateDesc| { &m.state },
                |m: &mut ContractStateDesc| { &mut m.state },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ContractStateDesc>(
                "ContractStateDesc",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ContractStateDesc {
        static instance: ::protobuf::rt::LazyV2<ContractStateDesc> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ContractStateDesc::new)
    }
}

impl ::protobuf::Clear for ContractStateDesc {
    fn clear(&mut self) {
        self.contract.clear();
        self.state.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ContractStateDesc {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ContractStateDesc {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ChunkMergeStub {
    // message fields
    pub index_range: ::std::vec::Vec<u32>,
    // message oneof groups
    pub _first_range: ::std::option::Option<ChunkMergeStub_oneof__first_range>,
    pub _last_range: ::std::option::Option<ChunkMergeStub_oneof__last_range>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ChunkMergeStub {
    fn default() -> &'a ChunkMergeStub {
        <ChunkMergeStub as ::protobuf::Message>::default_instance()
    }
}

#[derive(Clone,PartialEq,Debug)]
pub enum ChunkMergeStub_oneof__first_range {
    first_range(u32),
}

#[derive(Clone,PartialEq,Debug)]
pub enum ChunkMergeStub_oneof__last_range {
    last_range(u32),
}

impl ChunkMergeStub {
    pub fn new() -> ChunkMergeStub {
        ::std::default::Default::default()
    }

    // uint32 first_range = 1;


    pub fn get_first_range(&self) -> u32 {
        match self._first_range {
            ::std::option::Option::Some(ChunkMergeStub_oneof__first_range::first_range(v)) => v,
            _ => 0,
        }
    }
    pub fn clear_first_range(&mut self) {
        self._first_range = ::std::option::Option::None;
    }

    pub fn has_first_range(&self) -> bool {
        match self._first_range {
            ::std::option::Option::Some(ChunkMergeStub_oneof__first_range::first_range(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_first_range(&mut self, v: u32) {
        self._first_range = ::std::option::Option::Some(ChunkMergeStub_oneof__first_range::first_range(v))
    }

    // repeated uint32 index_range = 2;


    pub fn get_index_range(&self) -> &[u32] {
        &self.index_range
    }
    pub fn clear_index_range(&mut self) {
        self.index_range.clear();
    }

    // Param is passed by value, moved
    pub fn set_index_range(&mut self, v: ::std::vec::Vec<u32>) {
        self.index_range = v;
    }

    // Mutable pointer to the field.
    pub fn mut_index_range(&mut self) -> &mut ::std::vec::Vec<u32> {
        &mut self.index_range
    }

    // Take field
    pub fn take_index_range(&mut self) -> ::std::vec::Vec<u32> {
        ::std::mem::replace(&mut self.index_range, ::std::vec::Vec::new())
    }

    // uint32 last_range = 3;


    pub fn get_last_range(&self) -> u32 {
        match self._last_range {
            ::std::option::Option::Some(ChunkMergeStub_oneof__last_range::last_range(v)) => v,
            _ => 0,
        }
    }
    pub fn clear_last_range(&mut self) {
        self._last_range = ::std::option::Option::None;
    }

    pub fn has_last_range(&self) -> bool {
        match self._last_range {
            ::std::option::Option::Some(ChunkMergeStub_oneof__last_range::last_range(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_last_range(&mut self, v: u32) {
        self._last_range = ::std::option::Option::Some(ChunkMergeStub_oneof__last_range::last_range(v))
    }
}

impl ::protobuf::Message for ChunkMergeStub {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self._first_range = ::std::option::Option::Some(ChunkMergeStub_oneof__first_range::first_range(is.read_uint32()?));
                },
                2 => {
                    ::protobuf::rt::read_repeated_uint32_into(wire_type, is, &mut self.index_range)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self._last_range = ::std::option::Option::Some(ChunkMergeStub_oneof__last_range::last_range(is.read_uint32()?));
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.index_range {
            my_size += ::protobuf::rt::value_size(2, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        if let ::std::option::Option::Some(ref v) = self._first_range {
            match v {
                &ChunkMergeStub_oneof__first_range::first_range(v) => {
                    my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
                },
            };
        }
        if let ::std::option::Option::Some(ref v) = self._last_range {
            match v {
                &ChunkMergeStub_oneof__last_range::last_range(v) => {
                    my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.index_range {
            os.write_uint32(2, *v)?;
        };
        if let ::std::option::Option::Some(ref v) = self._first_range {
            match v {
                &ChunkMergeStub_oneof__first_range::first_range(v) => {
                    os.write_uint32(1, v)?;
                },
            };
        }
        if let ::std::option::Option::Some(ref v) = self._last_range {
            match v {
                &ChunkMergeStub_oneof__last_range::last_range(v) => {
                    os.write_uint32(3, v)?;
                },
            };
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ChunkMergeStub {
        ChunkMergeStub::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_u32_accessor::<_>(
                "first_range",
                ChunkMergeStub::has_first_range,
                ChunkMergeStub::get_first_range,
            ));
            fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "index_range",
                |m: &ChunkMergeStub| { &m.index_range },
                |m: &mut ChunkMergeStub| { &mut m.index_range },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_u32_accessor::<_>(
                "last_range",
                ChunkMergeStub::has_last_range,
                ChunkMergeStub::get_last_range,
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ChunkMergeStub>(
                "ChunkMergeStub",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ChunkMergeStub {
        static instance: ::protobuf::rt::LazyV2<ChunkMergeStub> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ChunkMergeStub::new)
    }
}

impl ::protobuf::Clear for ChunkMergeStub {
    fn clear(&mut self) {
        self._first_range = ::std::option::Option::None;
        self.index_range.clear();
        self._last_range = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ChunkMergeStub {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ChunkMergeStub {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ChunkFunctionMerge {
    // message fields
    pub chunks: ::protobuf::SingularPtrField<ChunkMergeStub>,
    pub split: u32,
    // message oneof groups
    pub _key: ::std::option::Option<ChunkFunctionMerge_oneof__key>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ChunkFunctionMerge {
    fn default() -> &'a ChunkFunctionMerge {
        <ChunkFunctionMerge as ::protobuf::Message>::default_instance()
    }
}

#[derive(Clone,PartialEq,Debug)]
pub enum ChunkFunctionMerge_oneof__key {
    key(::std::vec::Vec<u8>),
}

impl ChunkFunctionMerge {
    pub fn new() -> ChunkFunctionMerge {
        ::std::default::Default::default()
    }

    // bytes key = 1;


    pub fn get_key(&self) -> &[u8] {
        match self._key {
            ::std::option::Option::Some(ChunkFunctionMerge_oneof__key::key(ref v)) => v,
            _ => &[],
        }
    }
    pub fn clear_key(&mut self) {
        self._key = ::std::option::Option::None;
    }

    pub fn has_key(&self) -> bool {
        match self._key {
            ::std::option::Option::Some(ChunkFunctionMerge_oneof__key::key(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_key(&mut self, v: ::std::vec::Vec<u8>) {
        self._key = ::std::option::Option::Some(ChunkFunctionMerge_oneof__key::key(v))
    }

    // Mutable pointer to the field.
    pub fn mut_key(&mut self) -> &mut ::std::vec::Vec<u8> {
        if let ::std::option::Option::Some(ChunkFunctionMerge_oneof__key::key(_)) = self._key {
        } else {
            self._key = ::std::option::Option::Some(ChunkFunctionMerge_oneof__key::key(::std::vec::Vec::new()));
        }
        match self._key {
            ::std::option::Option::Some(ChunkFunctionMerge_oneof__key::key(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_key(&mut self) -> ::std::vec::Vec<u8> {
        if self.has_key() {
            match self._key.take() {
                ::std::option::Option::Some(ChunkFunctionMerge_oneof__key::key(v)) => v,
                _ => panic!(),
            }
        } else {
            ::std::vec::Vec::new()
        }
    }

    // .ChunkMergeStub chunks = 2;


    pub fn get_chunks(&self) -> &ChunkMergeStub {
        self.chunks.as_ref().unwrap_or_else(|| <ChunkMergeStub as ::protobuf::Message>::default_instance())
    }
    pub fn clear_chunks(&mut self) {
        self.chunks.clear();
    }

    pub fn has_chunks(&self) -> bool {
        self.chunks.is_some()
    }

    // Param is passed by value, moved
    pub fn set_chunks(&mut self, v: ChunkMergeStub) {
        self.chunks = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_chunks(&mut self) -> &mut ChunkMergeStub {
        if self.chunks.is_none() {
            self.chunks.set_default();
        }
        self.chunks.as_mut().unwrap()
    }

    // Take field
    pub fn take_chunks(&mut self) -> ChunkMergeStub {
        self.chunks.take().unwrap_or_else(|| ChunkMergeStub::new())
    }

    // uint32 split = 3;


    pub fn get_split(&self) -> u32 {
        self.split
    }
    pub fn clear_split(&mut self) {
        self.split = 0;
    }

    // Param is passed by value, moved
    pub fn set_split(&mut self, v: u32) {
        self.split = v;
    }
}

impl ::protobuf::Message for ChunkFunctionMerge {
    fn is_initialized(&self) -> bool {
        for v in &self.chunks {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self._key = ::std::option::Option::Some(ChunkFunctionMerge_oneof__key::key(is.read_bytes()?));
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.chunks)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.split = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.chunks.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if self.split != 0 {
            my_size += ::protobuf::rt::value_size(3, self.split, ::protobuf::wire_format::WireTypeVarint);
        }
        if let ::std::option::Option::Some(ref v) = self._key {
            match v {
                &ChunkFunctionMerge_oneof__key::key(ref v) => {
                    my_size += ::protobuf::rt::bytes_size(1, &v);
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.chunks.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if self.split != 0 {
            os.write_uint32(3, self.split)?;
        }
        if let ::std::option::Option::Some(ref v) = self._key {
            match v {
                &ChunkFunctionMerge_oneof__key::key(ref v) => {
                    os.write_bytes(1, v)?;
                },
            };
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ChunkFunctionMerge {
        ChunkFunctionMerge::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_bytes_accessor::<_>(
                "key",
                ChunkFunctionMerge::has_key,
                ChunkFunctionMerge::get_key,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ChunkMergeStub>>(
                "chunks",
                |m: &ChunkFunctionMerge| { &m.chunks },
                |m: &mut ChunkFunctionMerge| { &mut m.chunks },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "split",
                |m: &ChunkFunctionMerge| { &m.split },
                |m: &mut ChunkFunctionMerge| { &mut m.split },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ChunkFunctionMerge>(
                "ChunkFunctionMerge",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ChunkFunctionMerge {
        static instance: ::protobuf::rt::LazyV2<ChunkFunctionMerge> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ChunkFunctionMerge::new)
    }
}

impl ::protobuf::Clear for ChunkFunctionMerge {
    fn clear(&mut self) {
        self._key = ::std::option::Option::None;
        self.chunks.clear();
        self.split = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ChunkFunctionMerge {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ChunkFunctionMerge {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct DataSourceStubDesc {
    // message fields
    pub functions: ::protobuf::RepeatedField<ChunkFunctionMerge>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a DataSourceStubDesc {
    fn default() -> &'a DataSourceStubDesc {
        <DataSourceStubDesc as ::protobuf::Message>::default_instance()
    }
}

impl DataSourceStubDesc {
    pub fn new() -> DataSourceStubDesc {
        ::std::default::Default::default()
    }

    // repeated .ChunkFunctionMerge functions = 1;


    pub fn get_functions(&self) -> &[ChunkFunctionMerge] {
        &self.functions
    }
    pub fn clear_functions(&mut self) {
        self.functions.clear();
    }

    // Param is passed by value, moved
    pub fn set_functions(&mut self, v: ::protobuf::RepeatedField<ChunkFunctionMerge>) {
        self.functions = v;
    }

    // Mutable pointer to the field.
    pub fn mut_functions(&mut self) -> &mut ::protobuf::RepeatedField<ChunkFunctionMerge> {
        &mut self.functions
    }

    // Take field
    pub fn take_functions(&mut self) -> ::protobuf::RepeatedField<ChunkFunctionMerge> {
        ::std::mem::replace(&mut self.functions, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for DataSourceStubDesc {
    fn is_initialized(&self) -> bool {
        for v in &self.functions {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.functions)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.functions {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.functions {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> DataSourceStubDesc {
        DataSourceStubDesc::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ChunkFunctionMerge>>(
                "functions",
                |m: &DataSourceStubDesc| { &m.functions },
                |m: &mut DataSourceStubDesc| { &mut m.functions },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<DataSourceStubDesc>(
                "DataSourceStubDesc",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static DataSourceStubDesc {
        static instance: ::protobuf::rt::LazyV2<DataSourceStubDesc> = ::protobuf::rt::LazyV2::INIT;
        instance.get(DataSourceStubDesc::new)
    }
}

impl ::protobuf::Clear for DataSourceStubDesc {
    fn clear(&mut self) {
        self.functions.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for DataSourceStubDesc {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DataSourceStubDesc {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

static file_descriptor_proto_data: &'static [u8] = b"\
    \n\x16protos/contracts.proto\"V\n\x0cCacheStorage\x12\x1e\n\x08pub_http\
    \x18\x01\x20\x01(\tH\0R\x07pubHttp\x88\x01\x01\x12\x19\n\x08pub_cyfs\x18\
    \x02\x20\x01(\x08R\x07pubCyfsB\x0b\n\t_pub_http\"+\n\rBackupStorage\x12\
    \x1a\n\x08reserved\x18\x01\x20\x01(\rR\x08reserved\"-\n\x13ImmutableData\
    Source\x12\x16\n\x06chunks\x18\x01\x20\x03(\x0cR\x06chunks\"\xff\x04\n\
    \x0cContractDesc\x12F\n\x10data_source_type\x18\x01\x20\x01(\x0e2\x1c.Co\
    ntractDesc.DataSourceTypeR\x0edataSourceType\x12B\n\x11immut_data_source\
    \x18\x02\x20\x01(\x0b2\x14.ImmutableDataSourceH\0R\x0fimmutDataSource\
    \x12(\n\x0fmut_data_source\x18\x03\x20\x01(\x04H\0R\rmutDataSource\x12<\
    \n\x0cstorage_type\x18\x04\x20\x01(\x0e2\x19.ContractDesc.StorageTypeR\
    \x0bstorageType\x124\n\rcache_storage\x18\x05\x20\x01(\x0b2\r.CacheStora\
    geH\x01R\x0ccacheStorage\x127\n\x0ebackup_storage\x18\x06\x20\x01(\x0b2\
    \x0e.BackupStorageH\x01R\rbackupStorage\x12\x14\n\x05miner\x18\x07\x20\
    \x01(\x0cR\x05miner\x12\x19\n\x08start_at\x18\x08\x20\x01(\x04R\x07start\
    At\x12\x15\n\x06end_at\x18\t\x20\x01(\x04R\x05endAt\x12\x18\n\x07witness\
    \x18\n\x20\x01(\x0cR\x07witness\x12)\n\x0ewitness_dec_id\x18\x0b\x20\x01\
    (\x0cH\x02R\x0cwitnessDecId\x88\x01\x01\",\n\x0eDataSourceType\x12\r\n\t\
    Immutable\x10\0\x12\x0b\n\x07Mutable\x10\x01\"$\n\x0bStorageType\x12\t\n\
    \x05Cache\x10\0\x12\n\n\x06Backup\x10\x01B\r\n\x0bdata_sourceB\t\n\x07st\
    orageB\x11\n\x0f_witness_dec_id\"0\n\x16DataSourceChangedState\x12\x16\n\
    \x06chunks\x18\x01\x20\x03(\x0cR\x06chunks\"[\n\x17DataSourcePreparedSta\
    te\x12\x16\n\x06chunks\x18\x01\x20\x03(\x0cR\x06chunks\x12(\n\x10data_so\
    urce_stub\x18\x02\x20\x01(\x0cR\x0edataSourceStub\"\x9b\x03\n\rContractS\
    tate\x12?\n\nstate_type\x18\x01\x20\x01(\x0e2\x20.ContractState.Contract\
    StateTypeR\tstateType\x12I\n\x13data_source_changed\x18\x02\x20\x01(\x0b\
    2\x17.DataSourceChangedStateH\0R\x11dataSourceChanged\x12L\n\x14data_sou\
    rce_prepared\x18\x03\x20\x01(\x0b2\x18.DataSourcePreparedStateH\0R\x12da\
    taSourcePrepared\"\xa6\x01\n\x11ContractStateType\x12\x0b\n\x07Initial\
    \x10\0\x12\x15\n\x11DataSourceChanged\x10\x01\x12\x16\n\x12DataSourcePre\
    pared\x10\x02\x12\x15\n\x11DataSourceSyncing\x10\x03\x12\x14\n\x10DataSo\
    urceStored\x10\x04\x12\x14\n\x10ContractExecuted\x10\x05\x12\x12\n\x0eCo\
    ntractBroken\x10\x06B\x07\n\x05state\"U\n\x11ContractStateDesc\x12\x1a\n\
    \x08contract\x18\x01\x20\x01(\x0cR\x08contract\x12$\n\x05state\x18\x02\
    \x20\x01(\x0b2\x0e.ContractStateR\x05state\"\x9a\x01\n\x0eChunkMergeStub\
    \x12$\n\x0bfirst_range\x18\x01\x20\x01(\rH\0R\nfirstRange\x88\x01\x01\
    \x12\x1f\n\x0bindex_range\x18\x02\x20\x03(\rR\nindexRange\x12\"\n\nlast_\
    range\x18\x03\x20\x01(\rH\x01R\tlastRange\x88\x01\x01B\x0e\n\x0c_first_r\
    angeB\r\n\x0b_last_range\"r\n\x12ChunkFunctionMerge\x12\x15\n\x03key\x18\
    \x01\x20\x01(\x0cH\0R\x03key\x88\x01\x01\x12'\n\x06chunks\x18\x02\x20\
    \x01(\x0b2\x0f.ChunkMergeStubR\x06chunks\x12\x14\n\x05split\x18\x03\x20\
    \x01(\rR\x05splitB\x06\n\x04_key\"G\n\x12DataSourceStubDesc\x121\n\tfunc\
    tions\x18\x01\x20\x03(\x0b2\x13.ChunkFunctionMergeR\tfunctionsb\x06proto\
    3\
";

static file_descriptor_proto_lazy: ::protobuf::rt::LazyV2<::protobuf::descriptor::FileDescriptorProto> = ::protobuf::rt::LazyV2::INIT;

fn parse_descriptor_proto() -> ::protobuf::descriptor::FileDescriptorProto {
    ::protobuf::Message::parse_from_bytes(file_descriptor_proto_data).unwrap()
}

pub fn file_descriptor_proto() -> &'static ::protobuf::descriptor::FileDescriptorProto {
    file_descriptor_proto_lazy.get(|| {
        parse_descriptor_proto()
    })
}
