# DataChannel广播（腾讯会议场景）
1.加入一个Group,Group里的Peerid有身份（发言人，普通参会者，加速服务器）
2.在一个节点看来，他有两组Channel：自己发布数据的Channel，和自己订阅的Channel. 那么
一个典型的普通参会者的情况 (L,M,H代表3种最高码率)
  Sub(发言人1.音频H)，Sub(发言人1.视频H) ，Sub(发言人2.音频H)，Sub(发言人2.视频M)，Sub(发言人3.音频H)，Sub(发言人3.视频M);//不关心其它的参会者
  Pub(self.视频L)
一个典型的发言人的情况
  Sub(发言人2.音频H)，Sub(发言人2.视频M),Sub(参会者1.视频L)，Sub(参会者2.视频L)，Sub(参会者3.视频L)...
  Pub(self.视频H),Pub(self.音频H)
3.在运行期，任何人都可以根据App规则变成发言人
4.API接口：在完成Sub/Pub操作后，会返回一个URL地址（指向加速服务器），可以按标准协议推送流数据或则获得流数据
    let group = this.joinGroup(groupid);
    let pubURL = group.pub("")
    let subURL = group.sub("")
  
5.我们的实现：返回的URL是一个本地URL，这样就可以在本地做P2P加速

# 通用化
## RealTimeDataChannel （RTDataChannel）
明确来源：每一片数据都可以校验来源
时间轴：RealTimeDataChannel有当前时间，握手后可用本地时间进行同步管理
有效时间：每片数据有有效时间，超过有效时间的数据片应该被丢弃（如果路由器能看到的话）
实时优先级：在传输时，离当前时间越近的数据片优先级越高
数据帧：一个数据帧的大小可能会超过分片的大小，数据帧包含多个分片。根据实际情况，还存在I,P,B帧。拥有不同的传输优先级。对于音频数据来说，一帧数据并不大，但对视频来说，一帧数据在10K - 20K 不等
分层传输：数据帧不需要收到所有的分片就能开始decode.后续（按时了分片的顺序性）的分片可以直接塞入解码器
编码传输：数据帧被编码成多个分片，得到不重复/足够多的分片后可以解码出视频帧

Push
{
  OwenrID : u128
  ChannelID : u32
  CreateTime,(FrameID) : u32
  Valid: u16 //Frame的有效时长，以10ms为单位，RealTimeData的最大有效期是600秒（10分钟）
  CanDrop : u1 //该分片是否应该尽力保障达到
  LayerID : u4 //所属分层（清晰度）LayerID越低，优先级越高
  TTL : u4// P2P 转发次数 当到达16时不转发
  PieceID/Count : u16 //所属分片 256 / 256
  [AckInfo] //可以带上完成信息
} 12 + 16 = 28 bytes header.是否需要签名？保证不可篡改性。但校验很麻烦



数据头默认不加密。数据包部分的加密密钥，在Sub该Channel成功时能得到。


### 帧数据的转发


### 分片数据的转发
1.Group内的所有节点之间均建立连接
2.发言人的上传带宽优先加速节点
3.加速节点的下行带宽，优先发言人、其它加速节点
4.发言人只能指定一个“第一加速节点“”
5.加速节点会默认分配多个首选推送节点（进房间时可以进行拓扑测试）
6.策略：
加速节点决定优先给哪些节点推送数据，有的节点虽然和加速节点有带宽，但可能获得的数据很少
普通节点在收到数据后，会进行分片转发（有一个可转发列表Peer）
普通节点在收到一个完整的Frame后，会给所有曾经推送过该Frame分片的节点，回复Complete信息，Complete信息里包含在该源接收的分片总数和有效分片数


### Frame数据的分组大小
1片最大是1.3K左右
200KB 1秒视频，30帧，一个Frame大概6KB （6片）使用RS-Code编码 得到7-9片数据
基于Frame的广播拥塞控制算法（Frame窗口），期望在一个Channel广播的过程中，逐步得到一个稳定的分层扩散拓扑

### 两种模式
1.拥有数据的的稳定Publisher（通常这个节点也有昂贵的带宽成本）,到所有节点的延迟都很低，希望低成本的快速扩散数据
2.“一定能被连上”的中间节点 (M)，流量便宜，到不同节点的延迟不稳定。可以帮助Publisher来中转数据，可以做为一传手 
3.剩下的节点，难以被连上，容易掉线，延迟也不稳定。主要目的是希望能尽快地获得数据（哪怕清晰度不够都可以）
4.从延迟的角度考虑，大家的延迟过去是 Ts->p,现在可以变成Ts->m + Tm->p,就是尽量多承受一次中间节点的转发。如果Ts->m较小的话，那么两者近似

=> 调度算法
P:在进入房间的时候判断自己能不能成为M。
P:和S建立连接，和M建立连接
P:如果和S的链接中断，则重连，如果和M的连接中断，则尝试连别的M
S:优先给M发送数据，根据P的拥塞情况给P补充数据
M:转发M的数据，根据传输中P的拥塞情况给P补充数据，根据自己的拥塞情况踢掉P
基于Piece的优先级和拥塞控制

### 寻找共性

### 效果统计与激励


### 一些结论
通过Destination Peerid来区分是点到点通信还是组播
P2P广播的核心是转发（注意和IP转发的区别），我们可以在明文部分提供一些有利于路由器帮助转发的字段。这个和NDN的加速有相通之处。需要告诉路由器转发粒度
一对多的通信可以分有限目标（发送者知道所有的目标的PeerInfo)和无限目标（发送者不知道所有目标的PeerInfo）两种情况，这对加密方案的选择有所影响
有限广播的调度形式是多样的，我们鼓励应用层使用经济手段来实现，但系统可以提供足够的Toolkit
无限广播既要考虑性能，也要减少性能浪费。系统可以提供一个默认的实现。（这个默认实现的逻辑是我们BDT的重点）
在IP网络上的广播实现，从结果上看，一定是树型的。到达延迟取决于节点在树的第几层。平均深度为6层是无限目标广播比较理性的选择。


