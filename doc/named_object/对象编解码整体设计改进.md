
# 一、DescContent/BodyContent可以选择不同的编解码
    编解码格式默认是RawCodec，接口层也保留了之前的设计，在此基础上，可以支持不同格式的编解码，比如ProtoBuf,JSON等格式
    选择编码方式需要从以下几个角度考虑:

+ 兼容性，包括向前兼容和向后兼容
+ 编解码效率
+ 编解码的体积，以及是否需要压缩
+ 编码后的可读性

比如JSON、Protobuf这些格式是可以比较好做到向前向后兼容的，而默认的RawCodec只能做到向后兼容

# 二、DescContent/BodyContent分别增加format和version两个字段(u8)
    DescContent/BodyContent均增加了这两个字段，用以表示当前使用的编码格式和对应的版本  
    定义DescContent/BodyContent时候，需要指定这些信息，rust和ts里面有不同的处理方式

    需要注意的是，version和format字段是给DescContent/BodyContent扩展部分解码时候用的，协议栈内部的解码器并不会根据这些值的不同而做不同的处理，也就是自定义对象这个值要保证自己能看懂就可以

```rust
impl DescContent for UserDescContent {
    .....
    fn version(&self) -> u8 {
        // 当前格式版本，从0开始，默认为0
        0
    }
    fn format(&self) -> u8 {
        // 当前使用的编码方式，默认为RawCodec，自定义对象可以约定自己的方式
        OBJECT_CONTENT_CODEC_FORMAT_PROTOBUF
    }
}
impl BodyContent for UserBodyContent {
    ......

    // 同DescContent，同一个对象的DescContent和BodyContent可以选择不同的编码格式，版本线也可以不同
    fn version(&self) -> u8 {
        0
    }
    fn format(&self) -> u8 {
        OBJECT_CONTENT_CODEC_FORMAT_PROTOBUF
    }
}
```
```typescript
class UserDescContent extends DescContent {
    ......
    codec_info(): ContentCodecInfo {
        return {
            version: 0,
            format: OBJECT_CONTENT_CODEC_FORMAT_PROTOBUF,
        };
    }
}
class UserBodyContentDecoder extends BodyContentDecoder<UserBodyContent> {
    ......
    codec_info(): ContentCodecInfo {
        return {
            version: 0,
            format: OBJECT_CONTENT_CODEC_FORMAT_PROTOBUF,
        };
    }
}
```

# 三、DescContent/BodyContent增加了长度信息，自定义字段内部不再需要保存额外的长度字段
+ DescContent增加了u16的长度字段
+ BodyContent增加了USize的变长长度字段

### 1. 解码时候，会先读取此长度，然后截取对应大小的buffer并传给DescContent/BodyContent的解码器，解码器内部使用buffer.len()就可以获取到需要解码的目标长度，不需要再通过额外的方法或者其它途径来决定要解码的buffer的实际长度了  

### 2. 解码完毕时候，返回的buf也不必是正确的buf(有可能老版本的解码只读取了一部分buffer，剩余部分没读取，之前的模式下由于没有记录真正的长度，从而会导致后续的解码失败)，外部会根据实际长度跳过Content部分，继续下一个段的解码操作

```rust
struct UserBodyContent {
    fn format(&self) -> u8 {
        // 可以很方便的使用JSON格式的编解码了
        OBJECT_CONTENT_CODEC_FORMAT_JSON
    }
}

impl RawDecode for UserBodyContent {
    fn raw_decode(buf: &[u8]) -> BuckyResult<(Self, &[u8])> {
        // length就是整个content的实际长度，可以直接交由内部解码器解码
        let length = buf.len();
        
        // 对于json格式编码的content，就可以直接解析为json了，不用担心长度未知导致的解析错误
        let json_content = serde_json::from_slice(buf).unwrap();
        // ...... do sth. with json_content
    }
}
```

# 四、增加了version后，基于RawCodec可以默认实现向后兼容(新版本可以解析老版本的数据)
```rust

// 需要保留每个老版本的实现
mod v0 {
    // v0版本的实现
    struct UserDescContent {......}
    impl DescContent for UserDescContent {
        fn version(&self) -> u8 {
            // 当前格式版本，从0开始，默认为0
            0
        }
    }
}

// 当前的版本
const CURRENT_VERSION: u8 = 1;

// 当前版本的实现
struct UserDescContent {......}
impl DescContent for UserDescContent {
    fn version(&self) -> u8 {
        // 当前格式版本
        CURRENT_VERSION
    }
}

// 编码时候，默认编码使用最新版本的，所以这里默认处理即可
impl RawEncode for UserDescContent {.....}

// 解码时候，根据version选择对应的解码器
impl RawDecode for UserDescContent {
    // 默认解码，只对当前版本，在raw_decode_with_option内部调用
    fn raw_decode(buf: &[u8]) -> BuckyResult<(Self, &[u8])> {
        ......
    }

    fn raw_decode_with_option(buf: &[u8], opt: RawDecodeOption) -> BuckyResult<(Self, &[u8])> {
        // 如果非当前版本，那么需要调用对应的解码接口
        if (opt.version < CURRENT_VERSION) {
            if (opt.version == 0) {
                let (content_v0, buf) = mod0::UserDescContent::raw_decode(buf)?;

                // content_v0转换到当前版本
                let content_now = UserDescContent::try_from(content_v0)?;
                return Ok((content_now, buf));
            } else {
                // TODO 处理各个历史版本的解码
            }
        } else if (opt.vesion > CURRENT_VERSION) {
            // 老本版收到了新版本的对象，由于不支持向前兼容，直接返回错误
            return Err(BuckyError::new(BuckyErrorCode::NotSupport));
        }

        // 当前版本，直接解码
        return Self::raw_decode(buf);
    }
}
```
```typescript
const CURRENT_VERSION = 1;

namespace v0 {
    class UserBodyContent {......}

    // v0版本的解码器
    class UserBodyContentDecoder {......}
}

class UserBodyContent extends BodyContent {
    // 返回当前的版本信息
    codec_info(): ContentCodecInfo {
        return { version: CURRENT_VERSION, format: OBJECT_CONTENT_CODEC_FORMAT_RAW };
    }

    // 编码使用当前版本编解码
    raw_measure(ctx?: any, purpose?: any): BuckyResult<number> {......}
    raw_encode(buf: Uint8Array, ctx?: any, purpose?: any): BuckyResult<Uint8Array> {.....}
}

// ts的实现和rust版本类似，不过更简洁的直接在raw_decode的ctx参数里面附带了版本信息
class UserBodyContentDecoder extends BodyContentDecoder<T extends BodyContent> {
    raw_decode(buf: Uint8Array, ctx: ContentRawDecodeContext): BuckyResult<[T, Uint8Array]> {
        // 处理非当前版本的解码
        if (ctx.version < CURRENT_VERSION) {
            if (ctx.version === 1) {
                const decoder = new v0.UserBodyContentDecoder();
                const [content_v0, buf] = decoder.raw_decode(buf).unwrap();
                // v0转到当前版本
                const content = UserBodyContent.try_from_v0(content_v0).unwrap();
                return Ok([content, buf]);
            } else {
                // TODO 处理各个历史版本的解码
            }
        } else if (opt.vesion > CURRENT_VERSION) {
            // 老本版收到了新版本的对象，由于不支持向前兼容，直接返回错误
            return Err(nedw BuckyError(BuckyErrorCode.NotSupport));
        }

        // TODO 当前版本的正常解码...
    }
}

```

# 五、对象Desc和MutBody部分预留了再次扩展的能力
按照目前设计，Object的除了DescContent/BodyContent两个扩展部分外，其余部分基本不会发生改变；但为了以防万一，还是预留了再次扩展的能力，方便以后发生特殊情况时候扩展使用

+ Desc和MutBody都占用了一个bit的ext_flag，表示开启ext扩展段
+ 目前版本默认不开启ext扩展段，也就是ext_flag没有设置为1，所以没有任何开销
+ 开启该字段后，默认Desc/MutBody会增加一个(u16, buffer)的字段，里面扩展相应的内容(可以使用Protobuf等二级格式)
+ 支持向前兼容，目前版本如果读取到ext_flag=1，那么会主动跳过此段，避免解析出错