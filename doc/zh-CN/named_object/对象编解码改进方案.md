由于目前对象编解码使用的RawEncode/RawDecode存在兼容性问题，经过讨论决定在测试网上线前做一次改进，包括下面几点
+ 保留RawEncode/RawDecode作为基础编码
    整个解码接口体系并没改动，代码层兼容
+ Desc和Body部分增加额外的版本字段
    Desc和Body各增加了一个version字段(会导致现有的对象数据不兼容)
+ raw_decode接口解码增加版本参数，内部可以通过判断版本号对应解码(做到向后兼容)
    高版本的程序如果收到低版本的数据，可以选择使用老版本的raw格式解码，再转换到当前版本，用以实现向后兼容；反过来不成立
+ 提供基于protobuf的扩展编码解决方案
    这个会提供辅助函数、宏，实例代码和标准流程
+ 基础对象的Object部分+Desc部分保留Raw编码，Body部分切换为protobuf编码
+ 核心对象统一切换为protobuf编码
+ 扩展对象根据兼容需求，Desc+Body选择合适的编码方式
+ 增加format: u8字段，同一个对象的DescContent和BodyContent可以同时支持多种编解码
       用以处理不同的场景，编码格式的选择基于以下角度考虑
-	兼容性，包括向前兼容和向后兼容
-	编解码效率
-	编解码的体积，以及是否需要压缩
-	编码后的可读性
+ version字段统一改用u8
       这种raw级别的版本经过再三考虑，256个版本足够了，因为只用于重大格式改变；如果经常需要改变格式，那么直接上protobuf/json等自动兼容更好的
+ Desc和MutBody预留扩展能力
       目前的编解码只是考虑到了Desc和MutBody的自定义部分，而非自定义部分还是使用raw，并且不可修改和扩展；考虑到万一需要变动，所以还是占用了一个flags，用以实现兼容
       如果配置了flags，那么就存在一个额外的ExtBody，里面是扩展的内容；而老版本不识别此段格式，只需要读取长度，直接跳过

  原则上根据版本兼容、大小、效率等不同的需求，扩展对象可以选择自己合适的编码方法，比如protobuf，json，avro等，同一对象的编解码方式需要保持一致，外层Object的基础编码不会提供相应的类型字段，完全透明，由app自行处理

此版本修改后，会完全不兼容现有的数据和版本，需要全网升级，删除已有数据
PR团队需要在CYFS官方等地方增加相应的提示用语，告知开发测试网的所有用户