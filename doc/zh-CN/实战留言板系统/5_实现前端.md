# CYFS DEC APP 的前端结构介绍

前端代码在安装时已完全保存在 OOD 上，且一定和相应的后端匹配。
cyfs-sdk 已支持 typescript，为前端开发 Dec App 提供了强大的类型提示功能。
TODO:补充 a link 介绍

# CYFS 相关的前端初始化

- 完整代码见 src/www/initializa.ts

前端初始化主要是完成 3 个步骤：

1. 选择 OOD 环境(REAL)或者模拟器环境中的具体 Zone(FIRST or SECOND)
2. MetaClient 初始化，选择 beta
3. 打开并等待 Stack 上线

代码如下：

```typescript
export async function init() {
	useSimulator(SimulatorZoneNo.REAL, SimulatorDeviceNo.FIRST);
	MetaClient.init(MetaClient.EnvTarget.BETA);
	await waitStackRuntime(DEC_ID);
}
```

# 前端页面开发

- 页面组件见 src/www/pages/MessageBoard

在 Dec App 中，前端页面是用户最直接的交互终端。
为了让前端的交互尽可能简单，我们的留言板系统的只有一个前端页面，页面包含一个发布留言的输入区域和一个显示留言记录的展示区域。

## 发布留言

- 发起请求函数见 src/www/apis/message.ts

发布留言的页面元素包含一个`文本输入框`和一个`Leave A Message`按钮，见 src/www/pages/MessageBoard。
前端交互流程是在输入框输入留言的文本内容之后，点击`Leave A Message`按钮即发布新留言并刷新留言列表。

`发布新留言`需要完成以下 3 件事情：

1. 创建留言对象 Message
2. 发起发布留言请求
3. 解析响应对象

源码如下：

```typescript
// 发布留言
export async function publishMessage(content: string) {
	const stackWraper = checkStack();
	// 创建留言对象
	const messageObj = Message.create({
		content,
		decId: DEC_ID,
		owner: stackWraper.checkOwner(),
	});
	// 发起发布留言请求
	const ret = await stackWraper.postObject(messageObj, ResponseObjectDecoder, {
		reqPath: ROUTER_PATHS.PUBLISH_MESSAGE,
		decId: DEC_ID,
	});
	if (ret.err) {
		console.error(`reponse err, ${ret}`);
		return null;
	}
	// 解析 ResponseObject 对象
	const r = ret.unwrap();
	if (r) {
		const retObj = {
			err: r.err,
			msg: r.msg,
		};
		console.log(`reponse, ${retObj}`);
		return JSON.stringify(retObj);
	}
	return null;
}
```

## 修改留言

- 发起请求函数见 src/www/apis/message.ts

修改留言的页面元素包含在一个留言消息组件中，在留言消息的右下角有一个`Modify`按钮，点击该按钮后，显示一个`文本输入框`和一个`Submit`按钮。
前端交互流程是在输入框输入留言的文本内容之后，点击`Submit`按钮即可改变当前留言的内容并刷新留言列表。

`修改留言`需要完成以下 3 件事情：

1. 根据当前留言对象的 key 值和新的 content 内容，创建留言对象 Message
2. 发起更新留言请求
3. 解析响应对象

源码如下：

```typescript
// 更新留言
export async function updateMessage(msgKey: string, content: string) {
	const stackWraper = checkStack();
	// 根据当前留言对象的key值和新的content内容，创建留言对象 Message
	const MessageObj = Message.create({
		key: msgKey,
		content,
		decId: DEC_ID,
		owner: stackWraper.checkOwner(),
	});
	// 发起更新留言请求
	const ret = await stackWraper.postObject(MessageObj, ResponseObjectDecoder, {
		reqPath: ROUTER_PATHS.UPDATE_MESSAGE,
		decId: DEC_ID,
	});

	if (ret.err) {
		console.error(`reponse err, ${ret}`);
		return null;
	}
	// 解析 ResponseObject 对象
	const r = ret.unwrap();

	if (r) {
		const retObj = {
			err: r.err,
			msg: r.msg,
		};
		console.log(`reponse, ${retObj}`);
		return JSON.stringify(retObj);
	}
	return null;
}
```

## 删除留言

- 发起请求函数见 src/www/apis/message.ts

删除留言的页面元素包含在一个留言消息组件中，在留言消息的右下角有一个`Delete`红色按钮。
前端交互流程是点击`Delete`红色按钮后之后，当前留言被删除并刷新留言列表。

`删除留言`需要完成以下 3 件事情：

1. 根据当前留言对象的 key 值，创建留言对象 Message
2. 发起删除留言请求
3. 解析响应对象

源码如下：

```typescript
// 删除留言
export async function deleteMessage(msgKey: string) {
	const stackWraper = checkStack();
	// 根据当前留言对象的 key 值，创建留言对象 Message
	const MessageObj = Message.create({
		key: msgKey,
		content: "",
		decId: DEC_ID,
		owner: stackWraper.checkOwner(),
	});
	// 发起删除留言请求
	const ret = await stackWraper.postObject(MessageObj, ResponseObjectDecoder, {
		reqPath: ROUTER_PATHS.DELETE_MESSAGE,
		decId: DEC_ID,
	});
	if (ret.err) {
		console.error(`reponse err, ${ret}`);
		return null;
	}
	// 解析 ResponseObject 对象
	const r = ret.unwrap();
	if (r) {
		const retObj = {
			err: r.err,
			msg: r.msg,
		};
		console.log(`reponse, ${retObj}`);
		return JSON.stringify(retObj);
	}
	return null;
}
```
