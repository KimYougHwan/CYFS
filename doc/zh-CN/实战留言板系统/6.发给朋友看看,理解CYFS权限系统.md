# 发给好友测试一下

把上一个章节 `实现前端` 中的 `CYFS App Install Link` 对应的 Dec App 安装链接发给你的好友，然后，根据上一章的 `去 CYFS 浏览器中安装 Dec App 并查看` 的步骤指引，让你的好友也成功安装上我们的留言板 Dec App！

## 发布留言试试

你跟你的好友可以试试发布留言功能，你们各自会在自己的留言板上看到自己最新发布的留言信息，但是看不到对方的留言信息。
也就是说，折腾了这么久，现在只能看到自己的留言板信息，这就是个 `单机版` 的留言板。
你可能会问，要怎么样把 `单机版` 变成 `联机版`呢？
其实只需要 3 步：

1. 打开 src/common/constant.ts 文件，修改 `PEOPLE_IDS` 为`你自己的 peopleId` 以及`你好友的 peopleId`，查看 `peopleId`可以打开 CYFS 浏览器的`个人信息页`(cyfs://static/info.html)，头像下面的`DID`就是`peopleId`。
   注意：如果你想通知 2 个以上的好友，可以为`PEOPLE_IDS`设置超过 2 个`peopleId`。
2. 在留言服务的创建、修改和删除留言功能中增加通知好友同步的功能；
3. 开放以上功能对应的请求路径的必要权限(access)。

## 在留言服务中增加通知好友的功能

在原有的`单机版`留言基础上增加通知好友的功能，需要完成 2 个步骤：

1. 在原有的功能模块中增加跨 Zone 通知好友的代码；
2. 新增通知好友同步的请求路由模块。
   现在，我们根据这 2 个步骤来完成对`单机版`留言板的改造。

### 发布留言后跨 Zone 通知好友进行同步

#### 跨 Zone 通知好友

发布留言后跨 Zone 通知好友就是发送路径为`/messages/publish_req`的跨 Zone 请求，请求参数是新的留言对象。打开 src/service/routers/publish_message.ts 文件，放开以下代码的注释即可。

```typescript
const stackWraper = checkStack();
const peopleIds = getFriendPeopleIds();
await Promise.all(
	peopleIds.map(async (peopleId) => {
		return await stackWraper.postObject(messageObject, ResponseObjectDecoder, {
			reqPath: ROUTER_PATHS.PUBLISH_MESSAGE_REQ,
			decId: stack.dec_id!,
			target: cyfs.PeopleId.from_base_58(peopleId).unwrap().object_id, // Here is the difference between the same zone and cross zone.
		});
	})
);
```

---

发送 post 请求时，指定 `target` 即可实现跨 Zone 通知功能。

---

#### 同步好友

同步好友就是增加跨 Zone 通知好友对应的处理模块，对应的是 src/service/routers/publish_message_req.ts 文件。
我们打开 src/service/routers/publish_message_req.ts 文件，会发现其处理逻辑除了最开始的几行代码不同之外，其余的处理逻辑跟 src/service/routers/publish_message.ts 是一模一样的。
区别的代码如下：

```typescript
const stack = checkStack().check();
const owner = stack.local_device().desc().owner()!.unwrap();
console.log(`current target -----> ${req.request.common.target?.to_base_58()}`);
if (!owner.equals(req.request.common.target!)) {
	console.log(`should transfer to -> ${req.request.common.target}`);
	return Promise.resolve(
		cyfs.Ok({
			action: cyfs.RouterHandlerAction.Pass,
		})
	);
}
```

从这几行代码不难看出：跟处理同 Zone 的请求相比，在处理跨 Zone 请求时，需要判断自己的 OwnerId 是否与请求的 target 值相等，如果相等，说明这个请求还是在自己的 Zone 内，需要将其 Pass 转发到 Zone 外，也就是发给目标 Zone，如果不相等，说明是来自 Zone 外的请求，可以继续处理并响应。

接下来对修改留言和删除留言的也是遵循类似的处理，因此，不做详细的说明。

### 修改留言后跨 Zone 通知好友进行同步

#### 跨 Zone 通知好友

修改留言后跨 Zone 通知好友就是发送路径为`/messages/update_req`的跨 Zone 请求，请求参数也是新的留言对象。打开 src/service/routers/update_message.ts 文件，放开以下代码的注释即可。

```typescript
const stackWraper = checkStack();
const peopleIds = getFriendPeopleIds();
await Promise.all(
	peopleIds.map(async (peopleId) => {
		return await stackWraper.postObject(messageObject, ResponseObjectDecoder, {
			reqPath: ROUTER_PATHS.UPDATE_MESSAGE_REQ,
			decId: stack.dec_id!,
			target: cyfs.PeopleId.from_base_58(peopleId).unwrap().object_id, // Here is the difference between the same zone and cross zone.
		});
	})
);
```

#### 同步好友

- 源码见 src/service/routers/update_message_req.ts

### 删除留言后跨 Zone 通知好友进行同步

#### 跨 Zone 通知好友

删除留言后跨 Zone 通知好友就是发送路径为`/messages/delete_req`的跨 Zone 请求，请求参数是留言对象。打开 src/service/routers/delete_message.ts 文件，放开以下代码的注释即可。

```typescript
const stackWraper = checkStack();
const peopleIds = getFriendPeopleIds();
await Promise.all(
	peopleIds.map(async (peopleId) => {
		return await stackWraper.postObject(messageObject, ResponseObjectDecoder, {
			reqPath: ROUTER_PATHS.DELETE_MESSAGE_REQ,
			decId: stack.dec_id!,
			target: cyfs.PeopleId.from_base_58(peopleId).unwrap().object_id, // Here is the difference between the same zone and cross zone.
		});
	})
);
```

#### 同步好友

- 源码见 src/service/routers/delete_message_req.ts

## 再次发布留言试试能不能看到好友的留言

### 发布新代码到 OOD

经过上一节`在留言服务中增加通知好友的功能`的改造后，我们的留言板已经从`单机版`变成了`联机版`。
在执行发布流程前，请打开根目录下的 `cyfs.config.json` 文件，修改`version`的版本号，比如由原来的`1.0.1`升级为`1.0.2`。修改完成后，重新发布更新后的代码到 OOD。

发布完成后，自己跟好友就可以在 CYFS 浏览器的`应用商店`中对留言板 App 进行升级安装，参考上一个章节中的`去 CYFS 浏览器中升级 Dec App 并查看`。

### 试试能不能看到好友的留言

不出意外的话，你会发现在留言板中仍然看不到好友的最新留言。这是怎么回事呢？
其实，是因为权限不够。

## 首次面对权限问题

在 CYFS 中，每个请求里面都会包含两大块关键信息：**来源和目标**，协议栈通过根据来源，然后获取目标的 acl 配置，从而并来判断是否匹配。
对于一个请求，包含关键四元组信息：(source-device-id, source-dec-id) -> (target-device-id, target-dec-id)，权限系统基于四元组，判断该请求是否满足权限，从而决定是否放行。

### 权限系统的分类

在 CYFS 中，Dec App 的权限控制分为 2 类：

1. 申请自己的路径权限。
   如果是自己给自己开放权限，可以在 acl.toml 配置文件里设置，也可以在代码里动态注册。
   动态注册就是在 dec_ervice 运行中针对指定的 req_path 配置对应的权限。为 req_path 配置权限，就是设置不同的 req_path 对应的 access-string。
2. 申请其他 App 给自己开放权限。
   如果是想要请求其他 app 开放权限给自己，那么必须在 acl.toml 配置文件里写明，无法在代码中动态注册。
   配置好 acl.toml 文件之后，该文件会在 app 安装时，被 app-manager 读取，按照配置的各项值，向系统注册对应的权限。

#### 申请自己的路径权限

access-string 是参考 LINUX 下的文件系统的权限来设计的，使用 u32 来表示特定 group 的特定权限.

##### 权限分类

目前权限分为 Read、Write、Call 三种。
在设置权限的时候，可以单个权限去设置，即 AccessPermission，也可以通过组合多个权限去设置，减少代码量，即 AccessPermissions。
查看`cyfs-sdk`的声明文件，可以看到 AccessPermission 和 AccessPermissions 对应的源码如下：

```typescript
export class AccessPermission {
	static Call: AccessPermission;
	static Write: AccessPermission;
	static Read: AccessPermission;
}
export class AccessPermissions {
	static None: AccessPermissions;
	static CallOnly: AccessPermissions;
	static WriteOnly: AccessPermissions;
	static WirteAndCall: AccessPermissions;
	static ReadOnly: AccessPermissions;
	static ReadAndCall: AccessPermissions;
	static ReadAndWrite: AccessPermissions;
	static Full: AccessPermissions;
}
```

##### 权限分组

目前根据 zone、device 和 dec 共分为六个组：

1. CurrentZone：当前 zone 内设备(同一个 people 下绑定的所有设备)
2. FriendZone：好友设备，这个是好友列表里面的 People 下的所有设备
3. OthersZone：除当前 zone 和 friend zone 外的所有未知设备
4. CurrentDevice：当前设备
5. OwnerDec：当前 dec app
6. OthersDec: 其他的 dec app

每个分组都可以可以设置上一小节`权限分类`中的 3 个独立的权限：

```typescript
export class AccessGroup {
	static CurrentDevice: AccessGroup;
	static CurrentZone: AccessGroup;
	static FriendZone: AccessGroup;
	static OthersZone: AccessGroup;
	static OwnerDec: AccessGroup;
	static OthersDec: AccessGroup;
}
```

##### 操作方法

我们可以使用 AccessString 来生成对应的权限。比如想设置权限为同 zone 的所有 dec 可以 Read，那么应该参照如下代码去设置：

```typescript
import * as cyfs from "cyfs-sdk";

const access = new cyfs.AccessString(0);
access.set_group_permissions(
	cyfs.AccessGroup.CurrentDevice,
	cyfs.AccessPermissions.ReadOnly
);
access.set_group_permissions(
	cyfs.AccessGroup.CurrentZone,
	cyfs.AccessPermissions.ReadOnly
);
access.set_group_permissions(
	cyfs.AccessGroup.OwnerDec,
	cyfs.AccessPermissions.ReadOnly
);
access.set_group_permissions(
	cyfs.AccessGroup.OtherDec,
	cyfs.AccessPermissions.ReadOnly
);
```

#### 申请其他 App 给自己开放权限

##### 为什么要申请权限

如果是同 Zone 内，同 Dec 之间的 root-state 读写，add-handler 和 post_object，是不需要配置任何额外的权限的。

如果有跨 Zone，或者跨 Dec 的需求，就需要明确的配置权限：

- 对 root-state 的操作：根据读/写需求，配置 r 或 w 权限

- add-handler：如果要跨 Zone，或者跨 Dec 的 add-handler，需要给 add-handler 的虚路径配置对应的写权限

- post_object：如果要跨 Zone，或者跨 Dec 去 post_object，接收方必须给这个虚路径配置执行权限，即 x 权限

##### 配置方法

目前，有两种方法在 acl.toml 配置文件中表示一个 AccessString：

1. 完整的字符串，用一个 18 位字符串来表示一个完整权限，组内用 linux 的"rwx-"，表示每一位的权限。组和组之间可以用空格，或下划线分隔

   > 例：给 CurrentDevice，CurrentZone 的 OwnerDec 完整权限，给 FriendZone 的 OwnerDec 读写权限，给 OthersZone 的 OthersDec 读权限：

   > 表示上述权限的字符串为"rwxrwxrw-r--rwxr--", 它和"rwx rwx rw- r-- rwx r--", 还有"rwx_rwx_rw-\_r--\_rwx_r--"是等价的

2. 以默认权限为基础，单独为某几组标注权限: 表示为一个数组，数组内是{group, access}，group 为 AccessGroup 的枚举名，access 为三位的"rwx-"字符串

   > 默认的 AccessString 权限："rwxrwxrwx---rwx"

   > 还是以上述的权限为例，表示为`[{group = "FriendZone", access = "rw-"}, {group = "OthersZone", access = "r--"}, {group = "OthersDec", access = "r--"}]`

##### 一个完整的 acl.toml 实例

---

顶层的 key 为需要申请权限的 dec id，`self` 是特殊的 key，代表自己的 dec id。

---

```toml

[self]

[self.access]   // 配置自己三个路径的权限

// /test3 使用单独表示法配置权限

"/test3" = [{group = "OthersDec", access = "-wx"}, {group = "CurrentDevice", access = "---"}]

// 下边两个路径使用完整的字符串表示法配置权限

"/test2" = "rwxrwxrwx---rwx---"

"/test1" = "rwxrwxrwx---rwx--x"



[self.specified]    // 自己开放权限给其他的dec

"/test3" = {access = "--x", dec_id = "9tGpLNnDpa8deXEk2NaWGccEu4yFQ2DrTZJPLYLT7gj4"}    // 开放/test3的call权限给特定的dec

"/test2" = {access = "--x", zone_category = "current-zone", dec_id = "9tGpLNnDpa8deXEk2NaWGccEu4yFQ2DrTZJPLYLT7gj4"} // 开放/test2的call权限给特定的dec，并且只能是当前zone内调用

// 开放/test1的call权限，给特定zone内所有的dec

"/test1" = {access = "--x", zone = "5aSixgLwnWbmcDKwBtTBd7p9U4bmqwNU2C6h6SCvfMMh"}



// 为自己申请DECID_A的权限

[DECID_A.specified]

// 下边的SpecifiedGroup配置，不允许填写dec_id，这里的dec_id限定为自己。填写dec_id字段会导致当条配置无效

"/test3" = {access = "--x"} // 为自己申请特定dec的/test3 call权限

"/test2" = {access = "--x", zone_category = "current-zone"} // 为自己申请特定dec的/test2 call权限，只允许本zone内调用

"/test1" = {access = "--x", zone = "5aSixgLwnWbmcDKwBtTBd7p9U4bmqwNU2C6h6SCvfMMh"}// 为自己申请特定dec的/test2 call权限，只允许特定的zone发起调用



[DECID_A.config]    //由于目前config字段为空，这个配置段写不写都可以

```

## 如何添加合理的权限

通过前面章节`首次面对权限问题`的学习，我们已经掌握了配置权限的基本知识。但是，我们还不是很清楚：应该怎么样去合理的配置不同 req_path 的权限？
要知道，随意开放写权限是非常危险的行为——自己的 dec app 数据被别的恶意 dec app 改的一团糟甚至被全部清空，这会给自己造成严重的损失！
从`权限分类`中我们了解到，权限分为三大类：Read、Write、Call。
从`权限分组`中我们了解到，一共有 6 个分组：CurrentZone、FriendZone、OthersZone、CurrentDevice、OwnerDec 和 OthersDec。
现在我们来讲解如何针对这三种权限进行设置，便于我们在开发中正确的设置权限，为自己的 dec app 中的数据建立牢固的防火墙。

---

针对不同的分组开放不同等级的权限，依据的是我们对来源分组的信赖程度。

---

### Call 权限

1. 一般来说，我们是可以完全信赖 OwnerDec 发起的 Call 调用
2. 对于 CurrentZone、CurrentDevice、FriendZone、OthersZone 和 OthersDec，我们可以有选择性开放 Call 权限给部分或全部可信赖的来源分组，也可以认为这些来源都不可信，拒绝开放 Call 权限。

### Read 权限

1. 一般来说，我们是可以完全信赖 OwnerDec 发起的 Read 调用
2. 对于 CurrentZone、CurrentDevice、FriendZone、OthersZone 和 OthersDec，我们可以有选择性开放 Read 权限给部分或全部可信赖的来源分组，也可以认为这些来源都不可信，拒绝开放 Read 权限。

### Write 权限

1. 一般来说，我们是可以完全信赖 OwnerDec 发起的 Write 调用
2. 对于 CurrentZone、CurrentDevice、FriendZone、OthersZone 和 OthersDec，我们要谨慎的开放 Write 权限给部分可信赖的来源分组，也可以认为这些来源都不可信，拒绝开放 Write 权限。

## 为留言板设置权限：好友可 Call

学习了前面的有关`权限`的知识之后，我们现在来解决实现`联机版`留言板的最后问题——设置跨 Zone 请求对应的 CALL 权限。
打开 src/service/entry/app_startup.ts 文件，在`addRouters`方法中，放开如下代码段的注释即可：

```typescript
if (routerObj.reqPath.endsWith("_req")) {
	access.set_group_permissions(
		cyfs.AccessGroup.FriendZone,
		cyfs.AccessPermissions.CallOnly
	);
}
```

这段代码的意思是，对于包含以 `_req` 结尾的跨 Zone 请求路径，我们仅开放 Call 权限给自己的好友。

更改版本号之后，我们重新发布并安装最新版的 Dec App，会发现我们的留言板终于变成了`联机版`！
