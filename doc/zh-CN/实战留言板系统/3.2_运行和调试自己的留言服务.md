# DEC_Service 的端到端工作原理

CYFS 协议是对 HTTP 协议的整体升级，会尽量保持 HTTP 的近似语义。核心流程是：

> CYFS DEC App <--cyfs@http--> cyfs-rutnime <--cyfs@bdt--> gateway <--cyfs@http--> CYFS DEC Service

实际在网络中运行的 cyfs@bdt 协议并不会被 DEC App 的客户端和服务器直接使用，这个设计让 cyfs@bdt 协议的实现细节对应用开发者透明，让我们能有空间进行持续迭代，同时也能降低开发者的学习和使用门槛。

cyfs@http 协议会被 DEC App 开发者使用，因此起设计应是简洁易懂且长期稳定的。

# 进一步理解 CYFS 的 GET,PUT,CALL 系列协议语义

## GET 的协议流程

GET 协议在数据流转的流程上主要分为 3 步：

1. Step1: CYFS DEC App(浏览器) <-> cyfs-runtime@local (cyfs@http)

这是最常见的请求，所以其接口逻辑为向 local cyfs-runtime 平凡的发起一个 HTTP GET 请求。
按这个设计，当 cyfs-runtime 绑定本地的 80 端口时，如用户在 HOST 中把 o 配置为 127.0.0.1（或 cyfs-runtime 绑定的本地 virtual IP）,那么可以在传统浏览器中直接用
`http://o/$ownerid/$objectid` 打开。

2. Step2:cyfs-runtime <-> gateway (cyfs@BDT or BDT)

BDT 协议目前对应用透明，所以我们保留了根据应用实践改进性能的机会。比如可以为 NamedObject GET 定制专门的 BDT 协议报文。使用 HTTP@BDT Stream 是目前最稳定的实现。

按上述设计，这一层建立好正确的 BDT Stream 后，只需原样转发 HTTP 请求即可。因为 BDT 自带身份，所以 Req 中的 cyfs-from 和 Resp 中的 cyfs-remote 字段以删除以减少流量占用。

3. Step3:gateway <-> DEC Service (cyfs@http)

正常情况下，DEC Service 不应该 HANDLE NamedObject 的 GET 请求。gateway 的默认行为会自动的进行 NamedObject 查找，并返回结果.
默认行为下，对 GET NamedObject 的权限控制思路为

- Zone 内请求全放行，如果 Zone 内没有 OOD 会尝试去从其它地方获取。(`请求中的ownerid不一定要等于 OOD's Owner`)。
- Zone 外请求，如果请求的 Object 在 OOD 上没有，则直接返回 404。如果有，则判断该 Object 的 Owner，如果 Owner 不是 OOD's Owner,则返回。如果是，满足下面条件的请求放行：来源于“好友 Zone”;NamedObject 为 Public;有效的 ContextId（详见 Context 管理）

DEC Service 可以按 SDK 里 gateway 部分的接口，设置 GET NamedObject Handler。设置后的基本流程和 nginx upstream 类似，流程如下:

> `gateway-req->data_firewall->dec_service->data_firewall-resp->gateway`
> gateway 在把请求转发给 DEC Service 之前，以及 DEC Service 完成处理产生 Response 之后，都会经过数据防火墙的处理。

- 我们现在还未开放 GET NamedObject Handler.

## PUT 的协议流程

PUT 协议在数据流转的流程上主要分为 3 步：

1. Step1: CYFS DEC App(浏览器) <-> cyfs-runtime@local (cyfs@http)
   Reqeust

```
PUT http://o/$ownerid/$objectid HTTP/1.1
[cyfs-from:$deviceid] // 如果填写，说明App希望用指定身份发起请求
[cyfs-target:$deviceid] // 如果填写，说明要到达的具体设备
[cyfs-decid:$decid] //发起请求的decid。
[cyfs-cache-time:$time] //希望缓存的时间
(Body) 为NamedObject的二进制编码
```

Response

```
HTTP/1.1 200 OK //该NamedObject已经被缓存
[cyfs-remote:$remote-device-id]
[cyfs-cache-time:$time] //决定缓存的时间
```

2. Step2 cyfs-runtime <-> gateway or cyfs-runtime (cyfs@BDT)
   建立好正确的 BDT Stream 后，原样转发 HTTP 请求到目标设备。因为 BDT 自带身份，所以 Req 中的 cyfs-from 和 Resp 中的 cyfs-remote 字段以删除以减少流量占用。
3. Step3:gateway or cyfs-runtime <-> DEC Service / Named Object Cache (cyfs@http)
   cyfs-runtime 里通常不允许 DEC App Set Handler.这里我们讨论 Gateway 的情况。
   gateway 的一般 HANDLE 逻辑如下：

- 来自 Zone 内的 PUT 默认接受
- 来自 Zone 外的 PUT 默认拒绝

## POST(CALL) 的协议流程

POST(CALL) 协议在数据流转的流程上主要分为 3 步：

1. Step1: CYFS DEC App(浏览器) <-> cyfs-runtime@local (cyfs@http)
   Request

```
POST http://r/$ownerid/$decid/$dec_name?d1=objid1&d2=objid2 HTTP/1.1
[cyfs-from:$deviceid] // 如果填写，说明App希望用指定身份发起请求
[cyfs-decid:$decid] //发起请求的decid。
[cyfs-dec-action:exeucte | verify]
```

POST Call 的 Body 中可以带一组 package 的 named object。但大部分情况下，由 DEC Service 自行 Prepare。

Response

```
HTTP/1.1 200 OK
cyfs-dec-state: complete | prepare | running | wait_verify| failed //本次dec是完成，准备中，正在工作，等待验证，失败
cyfs-dec-finish : $time //dec完成的时间（dec不会重复执行，如果之前已经完成过，会用之前的时间）
cyfs-prepare : objid1,objid2,objid3 ... // 如果处在准备状态的
```

Response Body：如果 action 是执行，则返回 Result ObjectIds.如果是验证，验证通过返回对 DEC 三元组的签名。

2. Step2 cyfs-runtime <-> gateway (cyfs@BDT)

3. Step3:gateway <-> DEC Service (cyfs@http)

整个流程基本是 HTTP POST Request 和 Response 的原样转发,也是 DEC Service 会主要 Handle 的请求

# 深入探究 Service 启动程序

- 完整代码见 src/service/entry/app_startup.ts

Service 启动程序的入口为 main 函数，主要完成 3 个步骤：

1. 开启 Service 日志。
2. 打开并等待 Stack 上线。
3. 在 Stack 上注册路由模块。

## 开启 Service 日志

日志可以让我们快速的发现并定位问题，对解决线上问题十分有帮助。不同的操作系统，应用日志的存储路径略有不同；

- mac: ~/Library/cyfs/log/app/<app_name>
- windows: C:\cyfs\log\app\<app_name>
- linux: /cyfs/log/app/<app_name>

基于 CYFS SDK 开启 Service 日志非常简单，代码如下：

```typescript
import * as cyfs from "cyfs-sdk";

cyfs.clog.enable_file_log({
	name: APP_NAME,
	dir: cyfs.get_app_log_dir(APP_NAME),
});
```

## 打开并等待 Stack 上线

通过引入 cyfs_helper 中的 waitStackOOD 方法，我们可以很方便实现打开并等待 Stack 上线，代码如下：

```typescript
import { waitStackOOD } from "src/common/cyfs_helper/stack_wraper";

const waitR = await waitStackOOD(DEC_ID);
if (waitR.err) {
	console.error(`service start failed when wait stack online, err: ${waitR}.`);
	return;
}
```

## 在 Stack 上注册路由

使用 addRouters 方法来批量注册路由，提高开发效率。addRouters 方法中通过遍历封装了全部路由模块的`routers`对象，完成批量注册的功能。在每一轮循环中，主要完成 2 个任务：

1. 为请求路径 req_path 动态设置 access 权限，这里我们为每一个请求路径都开放 CurrentZone、CurrentDevice 和 OwnerDec 的写和 call 权限。
2. 使用 add_post_object_handler 方法将路由模块挂载到 Stack 上的指定请求路径下。

addRouters 代码如下：

```typescript
import * as cyfs from "cyfs-sdk";

export type RouterArray = Array<{
	reqPath: string;
	router: postRouterHandle;
}>;

async function addRouters(
	stack: cyfs.SharedCyfsStack,
	routers: RouterArray
): Promise<void> {
	for (const routerObj of routers) {
		// 为 req_path 设置 access 权限
		const access = new cyfs.AccessString(0);
		access.set_group_permissions(
			cyfs.AccessGroup.OwnerDec,
			cyfs.AccessPermissions.Full
		);
		const ra = await stack
			.root_state_meta_stub()
			.add_access(
				cyfs.GlobalStatePathAccessItem.new(routerObj.reqPath, access)
			);
		if (ra.err) {
			console.error(`path (${routerObj.reqPath}) add access error: ${ra}`);
			continue;
		}
		console.log("add access successed: ", ra.unwrap());
		// 挂载路由模块到指定的 req_path
		const handleId = `post-${routerObj.reqPath}`;
		const r = await stack
			.router_handlers()
			.add_post_object_handler(
				cyfs.RouterHandlerChain.Handler,
				handleId,
				1,
				undefined,
				routerObj.reqPath,
				cyfs.RouterHandlerAction.Pass,
				new PostRouterReqPathRouterHandler(routerObj)
			);

		if (r.err) {
			console.error(`add post handler (${handleId}) failed, err: ${r}`);
		} else {
			console.info(`add post handler (${handleId}) success.`);
		}
	}
}
```

# 调试

我们推荐采用前后端分离的方式去开发 dec app。
到目前为止，留言板的 dec_service 已经开发完毕。
现在我们把服务发布到 OOD 并对各项功能接口进行调试。

## 编译和打包项目

在项目根目录下，运行如下指令：

```shell
yarn build
```

指令执行完，可以在项目根目录下看到新增了 deploy 文件夹。

- deploy: 发布到 OOD 的文件夹，包含了项目中所有 ts 文件 编译后的 js 文件，由 tsconfig.json 配置

## 发布服务到 OOD

我们先打开 CYFS 浏览器再运行如下指令:

- mac

```shell
yarn mac-deploy-pre
yarn deploy
```

---

如果过程中出现以下错误：

```
[error],[2022-09-14 19:39:09.175],<>,owner mismatch, exit deploy., cyfs.js:389
```

这个报错代表当前的 owner 与应用的 owner 不匹配，我们需要手动修改应用的 owner，在项目根目录打开终端，输入以下指令：

```shell
cyfs modify -o ~/.cyfs_profile/people
yes
```

执行命令，打印出 _save app object success_ 的字样，代表修改成功。此时，我们重新走一遍发布流程即可。

---

- windows

```shell
yarn deploy
```

最终，终端会显示上传的信息，上传完成后，终端显示如下信息：

```
Upload DecApp Finished.
CYFS App Install Link: cyfs://5r4MYfFbqqyqoA4RipKdGEKQ6ZSX3JzNRaEpMPKiKWAQ/9tGpLNnbNtojWgQ3GmU2Y7byFm7uHDr1AH2FJBoGt5YF
```

恭喜你，这代表我们的 dec_service 已经成功发布到了 OOD。

请把`CYFS App Install Link`对应的链接复制下来，下一节我们将会使用这个链接进行 dec_service 的安装。

## 安装 dec_service

在上一节`发布服务到 OOD`中，我们已经成功把 dec_service 发布到了 OOD 上。现在，我们来安装 dec_service。

1. 复制 `CYFS App Install Link` 后面的这串 CYFS 链接，去 CYFS 浏览器中打开 Dec App Store 页面(cyfs://static/DecAppStore/app_store_list.html)，点击*通过 URL 安装*按钮，把安装链接粘贴进去，安装即可。
2. 安装完成后，可以去应用已安装列表页面(cyfs://static/DecAppStore/app_installed_list.html)看到刚刚安装好的 dec_service。

## 对各功能进行调试

到这里，我们的 dec_service 已经在 OOD 上运行起来了。现在，我们来对留言的增删改查功能进行调试。

---

测试发布新留言、修改留言以及删除留言后，可以参考下文的`使用命令行工具查看 root_state`去查看最新的 root_state

---

### 调试发布留言功能

- 完整源码见 src/service/test/publish_message_test.ts

调试发布留言模块的主入口是 main 函数，需要完成以下 3 个步骤：

1. 初始化 Stack
2. 设置新的留言内容(content)
3. 发起请求

如果接口正常，控制台会打印`publish message successed msgKey is ${msgKey}, result: ${r}`，其中的 msgKey 就是新建留言对象的 key 值。
否则，打印`publish message failed.`

---

建议复制控制台打印的新留言对象的 key 值，用来供接下来的查询、修改和删除的功能调试使用。

---

### 调试查询留言功能

- 完整源码见 src/service/test/retrieve_message_test.ts

调试查询留言模块的主入口是 main 函数，需要完成以下 3 个步骤：

1. 初始化 Stack
2. 设置要查询的留言对象 key 值
3. 发起请求

如果接口正常，控制台会打印`current Message key is ${msgRawObj.key}, content is ${msgRawObj.content}`，其中包含留言对象的 key 值和 content 内容。
否则，打印`retrieve message failed.`

### 调试修改留言功能

- 完整源码见 src/service/test/update_message_test.ts

调试修改留言模块的主入口是 main 函数，需要完成以下 3 个步骤：

1. 初始化 Stack
2. 设置将要修改的留言对象 key 值和新的 content 值
3. 发起请求

如果接口正常，控制台会打印`update message successed: ${r}`。
否则，打印`update message failed.`

### 调试删除留言功能

- 完整源码见 src/service/test/deletee_message_test.ts

调试删除留言模块的主入口是 main 函数，需要完成以下 3 个步骤：

1. 初始化 Stack
2. 设置将要删除的留言对象 key 值
3. 发起请求

如果接口正常，控制台会打印`delete message successed`。
否则，打印`delete message failed.`

## 使用命令行工具查看 root_state

使用 CYFS-SHELL 可以快速的感知到 root_state 上的数据状态改变。

### CYFS-SHELL 使用

1. 输入 cyfs shell [ -e runtime/ood],进入交互式命令行, 选择 device_id 和 dec_id 后进入对应的 Root-State 根。
2. 使用以下指令

- ls: 列出该目录下所有子节点

- cd: 进入该子节点,如果子节点不是 ObjectMap,提示错误,并留在当前目录

- cat: 以 json 格式展示该子节点的对象内容

- dump: 以二进制格式保存该子节点的对象内容,保存路径默认为当前路径,保存文件名为.obj

- get: 保存该节点和后续节点的文件到本地,保存路径默认为当前路径+节点名

- rm:删除节点,如果节点是 object map, 且还有子节点,删除失败

- target: 重新选择 target,选择后路径重置为根目录

- clear: 清除屏幕

- help: 帮助信息

- exit: 退出 shell

## 用浏览器查看 root_state

暂不支持
