# 工程结构

在根目录下，有 3 个文件夹及 11 个文件：

1. doc: 项目有关的文档
2. src: 项目的主文件夹
3. tools: 项目有关的工具程序。
4. .eslintignore: eslintignore 文件
5. .eslintrc.json: eslint 配置文件
6. .gitignore: gitignore 文件
7. cyfs.config.json: 发布 dec app 到 ood 的配置文件
8. move_deploy.js: 发布 dec app 到 ood 前必要的文件转移
9. package.json: 项目配置文件
10. prettier.config.js: prettier 配置文件
11. README.md: README 文件
12. service_package.cfg: 发布 dec app 到 ood 的 service 端打包配置文件
13. tsconfig.json: typescript 配置文件
14. typing.d.ts: 全局声明文件

_注意_ cyfs.config.json 文件中有个 app_id 的属性，app_id 是由 owner id 和 app_name 计算得来的 app id，不能自行修改。在代码中有一些地方必须使用 Dec App Id ，请使用这里展示的 ID。

在 src 目录下，有三个子文件夹：

1. common: 前端和 Service 端可以共同复用的代码
2. service: Service 工程代码
3. www: 前端工程代码

# 基于 ObjectMap 的 RootState 介绍

在 Web 语义化的过程中，产生了特别两个特别重要的标准:XML 和 json,都证明了存在一种通用的格式，可以用来描述所有的结构化信息。`命名容器对象`就是对这个设计的命名化发展：有相同语义的`命名容器对象`，必然会得到相同的 ObjectId。CYFS 标准里包含了 ObjectMap,ObjectSet...等标准命名容器对象。其中最重要的是 ObjectMap。其设计如下

```plain
ObjectMap {
    owner:ObjectId,
    values:map<String,ObjectId>,
}
```

在 ObjectMap 的 values 中引用另一个 ObjectMapId,形成了一种“树状结构”。

这个结构与传统的文件系统类似：树上的每一个命名对象类似文件，都一个通过一个"/key1/key2/key3"的唯一路径来表示。在这个结构中，任何一个命名对象的改变，都会导致其 ObjectId 改变，最终导致第一层的 ObjectMap 的 ObjectId 改变。而得到了第一层 ObjectMap 的 ObjectId,就可以逐层将整个树结构可信的重建出来。这个第一层 ObjectMap 由被称作"RootMap"。

以太坊为每个智能合约，提供了基于 storage trie 的 state object 来隔离的管理应用数据。CYFS 在语义上，则要求每个 DEC App 基于 RootObjectMap 来构建 App 的`RootState`。对开发者来说，构建 App 一致性状态的心智模型接近传统的文件系统，但进一步拥有了基于 RootObjectMap Id 来表达 DEC App 的一个确定状态的能力。我们把这个设计称作`命名对象文件系统`。这是也是 OOD 上的基础服务之一。可以通过`$app_id`的方式，来指向不同 DEC App 的`RootState`,这组成了 OOD 上的根文件系统`RootFS`。

# 留言对象建模

- 完整代码见 src/common/objs/obj_proto.proto

对象建模就是为对象设计一些有具体意义的属性，使该对象能与其他对象区别开来。
留言对象包含两个属性：key 和 content。key 是留言对象的唯一标识，content 是留言的文本内容。
我们使用 proto3 作为对象建模的工具，在 porto 文件中做出以下设计：

```proto3
message Message {
	string key  = 1;
	string content = 2;
}
```

## 设计留言对象在 RootState 上的存储路径

- 详情见 src/doc/object_model.md

通过前面`基于 ObjectMap 的 RootState 介绍`小节的学习，我们知道，在 CYFS 中，包含了 ObjectMap,ObjectSet...等`标准命名容器对象`，这些`标准命名容器对象`用来存放命名对象。每一个命名对象都是通过一个"/key1/key2/key3"的唯一路径来表示。
留言对象也是命名对象的一种实例，这些对象应当保存在一个能代表`留言对象列表`的`命名容器对象`中，这个`命名容器对象`也有自己的路径，我们取名为`messages_list`。
也就是说，所有的留言对象都存放在`messages_list`这个`命名容器对象`中，即`/messages_list`这个路径下。
为了方便后续更高效的查找指定的留言对象，我们采用 ObjectMap 来存储所有的留言对象。你可以理解为：这些留言对象都被组织在一个 `Map` 对象中，其中的每一个留言对象都以键值对的形式存储，`键`为留言对象的`key`字符串，`值`为留言对象本身。
因此，留言对象在 RootState 上的存储结构如下所示：

```
|--messages_list
|   |--message1.key => Message object
|   |--message2.key => Message object
```

# 使用 RootState 实现留言的增删改查

通过前面的学习，你已经了解了 RootState 的基本原理、完成了为留言对象建模以及设计好了留言对象在 RootState 上的存储路径。
不过，你可能会问，该如何对 RootState 上的对象进行增删改查操作呢？
答案：使用 PathOpEnv
在 CYFS 中，对于任意一个 RootState 的状态，比如/a/b/c，除了叶子节点，每一级都是一个 ObjectMap，叶子节点可以是任意 ObjectId 或 ObjectMap、 ObjectSet 格式的容器等。PathOpEnv 实现了对 DEC 的 RootState 进行基于路径的操作。

为解决数据的一致性问题，PathOpEnv 采用基于`路径锁`的`事务`机制来实现对 RootState 上的对象数据的操作。
事务是指单个逻辑工作单元执行的一系列操作，要么完全地执行，要么完全地不执行。一个逻辑工作单元要成为事务，必须满足 ACID（原子性、一致性、隔离性和持久性）属性。

如果要对 RootState 上的对象进行 CRUD 操作，一个完整的的 PathOpEnv 事务会包含 3 个步骤：

1. 锁定路径(lock): 锁定一组 path，只有当前 PathOpEnv 才可以操作。一个路径被锁定后，该路径的父路径和子路径都会被锁定，别的 PathOpEnv 不可重复加锁，但兄弟路径不会被锁定，比如锁定路径/a/b/c，那么/a, /a/b, /a/d/c/d 都不可以再重复加锁，但/a/c, /a/b/d 这些路径都可以加锁。
2. 事务操作(CURD): 在指定路径创建对象(insert_with_path)、在指定路径更新对象(set_with_key)、从指定路径读取对象(get_by_path)以及从指定路径删除对象(remove_with_key)
3. 事务提交(commit): 使用 PathOpEnv 完成操作后，需要 commit 才会把所有修改操作更新到 RootState 上。如果只是读取操作，那么 commit 不会做任何事情。一个 PathOpEnv 只可以 commit/abort 一次，之后不可以再继续使用了。提交成功后，会返回对应的 DEC 和 Global 的 RootState 状态。

现在，我们小试牛刀一下，使用 RootState 实现对留言的增删改查功能。

## 新增留言

- 完整代码见 src/service/routers/publish_message.ts

要新增一条留言，核心是需要 4 个步骤：

1. 接收新的留言对象

```typescript
const { object, object_raw } = req.request.object;
// ...ignore
const decoder = new MessageDecoder();
const dr = decoder.from_raw(object_raw);
// ...ignore
const msgObject = dr.unwrap();
```

2. 使用 PathOpEnv 根据留言对象的 key 锁定新路径

```typescript
const msgPath = `/messages_list/${msgObject.key}`;
const paths = [msgPath];
// ...ignore
const lockR = await pathOpEnv.lock(paths, cyfs.JSBI.BigInt(30000));
```

3. 在 non 上使用新的留言对象进行更新

```typescript
// ...ignore
const nonObj = new cyfs.NONObjectInfo(
	msgObject.desc().object_id(),
	msgObject.encode_to_buf().unwrap()
);
const putR = await stack.non_service().put_object({
	common: {
		dec_id: decId,
		level: cyfs.NONAPILevel.NOC, // Local operation only, no network operation will be initiated
		flags: 0,
	},
	object: nonObj,
});
// ...ignore
```

4. 使用 PathOpEnv 执行 insert_with_path 操作

```typescript
const objectId = nonObj.object_id;
const rp = await pathOpEnv.insert_with_path(msgPath, objectId);
// ...ignore
```

5. 提交事务

```typescript
const ret = await pathOpEnv.commit();
// ...ignore
```

## 修改留言

- 完整代码见 src/service/routers/update_message.ts

要新增一条留言，核心是需要 6 个步骤：

1. 接收新的留言对象(指定 key 值)

```typescript
const { object, object_raw } = req.request.object;
// ...ignore
const decoder = new MessageDecoder();
const dr = decoder.from_raw(object_raw);
// ...ignore
const MessageObject = dr.unwrap();
```

2. 使用 PathOpEnv 根据留言对象的 key 锁定对象路径

```typescript
const queryMessagePath = `/messages_list/${MessageObject.key}`;
const paths = [queryMessagePath];
// ...ignore
const lockR = await pathOpEnv.lock(paths, cyfs.JSBI.BigInt(30000));
```

3. 使用 PathOpEnv 读取旧的留言对象

```typescript
const idR = await pathOpEnv.get_by_path(queryMessagePath);
// ...ignore
const oldObjectId = idR.unwrap();
// ...ignore
```

4. 在 non 上使用新的留言对象进行更新

```typescript
const nonObj = new cyfs.NONObjectInfo(
	MessageObject.desc().object_id(),
	MessageObject.encode_to_buf().unwrap()
);
// ...ignore
const putR = await stack.non_service().put_object({
	common: {
		dec_id: decId,
		level: cyfs.NONAPILevel.NOC,
		flags: 0,
	},
	object: nonObj,
});
// ...ignore
```

5. 使用 PathOpEnv 执行 set_with_path 操作

```typescript
const newObjectId = nonObj.object_id;
const rs = await pathOpEnv.set_with_path(
	queryMessagePath,
	newObjectId!,
	oldObjectId,
	true
);
// ...ignore
```

6. 提交事务

```typescript
const ret = await pathOpEnv.commit();
// ...ignore
```

## 删除留言

- 完整代码见 src/service/routers/delete_message.ts

要新增一条留言，核心是需要 5 个步骤：

1. 接收要删除的留言对象(指定 key 值)

```typescript
const { object, object_raw } = req.request.object;
// ...ignore
const decoder = new MessageDecoder();
const dr = decoder.from_raw(object_raw);
// ...ignore
const MessageObject = dr.unwrap();
```

2. 使用 PathOpEnv 根据留言对象的 key 锁定对象路径

```typescript
const queryMessagePath = `/messages_list/${MessageObject.key}`;
const paths = [queryMessagePath];
// ...ignore
const lockR = await pathOpEnv.lock(paths, cyfs.JSBI.BigInt(30000));
```

3. 使用 PathOpEnv 读取要删除的留言对象 objectId

```typescript
const idR = await pathOpEnv.get_by_path(queryMessagePath);
// ...ignore
const objectId = idR.unwrap();
// ...ignore
```

4. 使用 PathOpEnv 执行 remove_with_path 操作

```typescript
const rm = await pathOpEnv.remove_with_path(queryMessagePath, objectId);
// ...ignore
```

5. 提交事务

```typescript
const ret = await pathOpEnv.commit();
// ...ignore
```

## 查询留言

- 完整代码见 src/service/routers/retrieve_message.ts

要新增一条留言，核心是需要 5 个步骤：

1. 接收要查询的留言对象(指定 key 值)

```typescript
const { object, object_raw } = req.request.object;
// ...ignore
const decoder = new MessageDecoder();
const dr = decoder.from_raw(object_raw);
// ...ignore
const MessageObject = dr.unwrap();
```

2. 使用 PathOpEnv 根据留言对象的 key 锁定对象路径

```typescript
const queryMessagePath = `/messages_list/${MessageObject.key}`;
const paths = [queryMessagePath];
// ...ignore
const lockR = await pathOpEnv.lock(paths, cyfs.JSBI.BigInt(30000));
```

3. 使用 PathOpEnv 读取要查询的留言对象 objectId

```typescript
const idR = await pathOpEnv.get_by_path(queryMessagePath);
// ...ignore
const objectId = idR.unwrap();
// ...ignore
```

4. 在 non 上获取留言对象

```typescript
const gr = await stack.non_service().get_object({
	common: { level: cyfs.NONAPILevel.NOC, flags: 0 },
	object_id: objectId,
});
// ...ignore
```

5. 释放锁

```typescript
pathOpEnv.abort();
// ...ignore
```
