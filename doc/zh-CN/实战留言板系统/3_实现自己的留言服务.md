# 工程结构

TODO 补充一下基于cyfs工具链创建项目的流程。

在根目录下，有 3 个文件夹及 11 个文件：

1. doc: 项目有关的文档
2. src: 项目的主文件夹
3. tools: 项目有关的工具程序。
4. .eslintignore: eslintignore 文件
5. .eslintrc.json: eslint 配置文件
6. .gitignore: gitignore 文件
7. cyfs.config.json: 发布 dec app 到 ood 的配置文件
8. move_deploy.js: 发布 dec app 到 ood 前必要的文件转移
9. package.json: 项目配置文件
10. prettier.config.js: prettier 配置文件
11. README.md: README 文件
12. service_package.cfg: 发布 dec app 到 ood 的 service 端打包配置文件
13. tsconfig.json: typescript 配置文件
14. typing.d.ts: 全局声明文件

_注意_ cyfs.config.json 文件中有个 app_id 的属性，app_id 是由 owner id 和 app_name 计算得来的 app id，不能自行修改。在代码中有一些地方必须使用 Dec App Id ，请使用这里展示的 ID。

在 src 目录下，有三个子文件夹：

1. common: 前端和 Service 端可以共同复用的代码
2. service: Service 工程代码
3. www: 前端工程代码


# 留言对象建模

TODO：这里要做一些进一步的说明
1. 回顾NamedObject结构
2. 稳定编码，我们用protobuf
3. 64KB编码长度限制，一些解决问题的方法


- 完整代码见 src/common/objs/obj_proto.proto

对象建模就是为对象设计一些有具体意义的属性，使该对象能与其他对象区别开来。
留言对象包含两个属性：key 和 content。key 是留言对象的唯一标识，content 是留言的文本内容。
我们使用 proto3 作为对象建模的工具，在 porto 文件中做出以下设计：

```proto3
message Message {
	string key  = 1;
	string content = 2;
}
```

TODO：补充编写完ProtoBuffer后，产生的代码的逻辑说明。

## 设计留言对象在 RootState 上的存储路径

- 详情见 src/doc/object_model.md （TODO： 要引入）

通过前面`基于 ObjectMap 的 RootState 介绍`小节的学习，我们知道，在 CYFS 中，包含了 ObjectMap,ObjectSet...等`标准命名容器对象`，这些`标准命名容器对象`用来存放命名对象。每一个命名对象都是通过一个"/key1/key2/key3"的唯一路径来表示。
留言对象也是命名对象的一种实例，这些对象应当保存在一个能代表`留言对象列表`的`命名容器对象`中，这个`命名容器对象`也有自己的路径，我们取名为`messages_list`。
也就是说，所有的留言对象都存放在`messages_list`这个`命名容器对象`中，即`/messages_list`这个路径下。
为了方便后续更高效的查找指定的留言对象，我们采用 ObjectMap 来存储所有的留言对象。你可以理解为：这些留言对象都被组织在一个 `Map` 对象中，其中的每一个留言对象都以键值对的形式存储，`键`为留言对象的`key`字符串，`值`为留言对象本身。
因此，留言对象在 RootState 上的存储结构如下所示：(TODO：这里应该是标题对应对象，这样允许更新)

```
|--messages_list
|   |--message1.key => Message object
|   |--message2.key => Message object
```

# 使用 RootState API 实现留言的增删改查

通过前面的学习，你已经了解了 RootState 的基本原理、完成了为留言对象建模以及设计好了留言对象在 RootState 上的存储路径。
不过，你可能会问，该如何对 RootState 上的对象进行增删改查操作呢？
答案：使用 PathOpEnv （Root Path Operation Env）
在 CYFS 中，对于任意一个 RootState 的状态，比如/a/b/c，除了叶子节点，每一级都是一个 ObjectMap，叶子节点可以是任意 ObjectId 或 ObjectMap、 ObjectSet 格式的容器等。PathOpEnv 实现了对 DEC 的 RootState 进行基于路径的操作。

为解决数据的一致性问题，PathOpEnv 采用基于`路径锁`的`事务`机制来实现对 RootState 上的对象数据的操作。
事务是指单个逻辑工作单元执行的一系列操作，要么完全地执行，要么完全地不执行。一个逻辑工作单元要成为事务，必须满足 ACID（原子性、一致性、隔离性和持久性）属性。

如果要对 RootState 上的对象进行 CRUD 操作，一个完整的的 PathOpEnv 事务会包含 3 个步骤：

1. 锁定路径(lock): 锁定一组 path，只有当前 PathOpEnv 才可以操作。一个路径被锁定后，该路径的父路径和子路径都会被锁定，别的 PathOpEnv 不可重复加锁，但兄弟路径不会被锁定，比如锁定路径/a/b/c，那么/a, /a/b, /a/d/c/d 都不可以再重复加锁，但/a/c, /a/b/d 这些路径都可以加锁。
2. 事务操作(CURD): 在指定路径创建对象(insert_with_path)、在指定路径更新对象(set_with_key)、从指定路径读取对象(get_by_path)以及从指定路径删除对象(remove_with_key)
3. 事务提交(commit): 使用 PathOpEnv 完成操作后，需要 commit 才会把所有修改操作更新到 RootState 上。如果只是读取操作，那么 commit 不会做任何事情。一个 PathOpEnv 只可以 commit/abort 一次，之后不可以再继续使用了。提交成功后，会返回对应的 DEC 和 Global 的 RootState 状态。

现在，我们小试牛刀一下，使用 RootState 实现对留言的增删改查功能。

## 新增留言


- 完整代码见 src/service/routers/publish_message.ts

要新增一条留言，核心是需要 4 个步骤：

1. 接收新的留言对象

```typescript
const { object, object_raw } = req.request.object;
// ...ignore
const decoder = new MessageDecoder();
const dr = decoder.from_raw(object_raw);
// ...ignore
const msgObject = dr.unwrap();
```

2. 使用 PathOpEnv 根据留言对象的 key 锁定新路径

```typescript
const msgPath = `/messages_list/${msgObject.key}`;
const paths = [msgPath];
// ...ignore
const lockR = await pathOpEnv.lock(paths, cyfs.JSBI.BigInt(30000));
```

3. 在 non 上使用新的留言对象进行更新

```typescript
// ...ignore
const nonObj = new cyfs.NONObjectInfo(
	msgObject.desc().object_id(),
	msgObject.encode_to_buf().unwrap()
);
const putR = await stack.non_service().put_object({
	common: {
		dec_id: decId,
		level: cyfs.NONAPILevel.NOC, // Local operation only, no network operation will be initiated
		flags: 0,
	},
	object: nonObj,
});
// ...ignore
```

4. 使用 PathOpEnv 执行 insert_with_path 操作

```typescript
const objectId = nonObj.object_id;
const rp = await pathOpEnv.insert_with_path(msgPath, objectId);
// ...ignore
```

5. 提交事务

```typescript
const ret = await pathOpEnv.commit();
// ...ignore
```

## 修改留言

- 完整代码见 src/service/routers/update_message.ts

要新增一条留言，核心是需要 6 个步骤：

1. 接收新的留言对象(指定 key 值)

```typescript
const { object, object_raw } = req.request.object;
// ...ignore
const decoder = new MessageDecoder();
const dr = decoder.from_raw(object_raw);
// ...ignore
const MessageObject = dr.unwrap();
```

2. 使用 PathOpEnv 根据留言对象的 key 锁定对象路径

```typescript
const queryMessagePath = `/messages_list/${MessageObject.key}`;
const paths = [queryMessagePath];
// ...ignore
const lockR = await pathOpEnv.lock(paths, cyfs.JSBI.BigInt(30000));
```

3. 使用 PathOpEnv 读取旧的留言对象

```typescript
const idR = await pathOpEnv.get_by_path(queryMessagePath);
// ...ignore
const oldObjectId = idR.unwrap();
// ...ignore
```

4. 在 non 上使用新的留言对象进行更新

```typescript
const nonObj = new cyfs.NONObjectInfo(
	MessageObject.desc().object_id(),
	MessageObject.encode_to_buf().unwrap()
);
// ...ignore
const putR = await stack.non_service().put_object({
	common: {
		dec_id: decId,
		level: cyfs.NONAPILevel.NOC,
		flags: 0,
	},
	object: nonObj,
});
// ...ignore
```

5. 使用 PathOpEnv 执行 set_with_path 操作

```typescript
const newObjectId = nonObj.object_id;
const rs = await pathOpEnv.set_with_path(
	queryMessagePath,
	newObjectId!,
	oldObjectId,
	true
);
// ...ignore
```

6. 提交事务

```typescript
const ret = await pathOpEnv.commit();
// ...ignore
```

## 删除留言

- 完整代码见 src/service/routers/delete_message.ts

要新增一条留言，核心是需要 5 个步骤：

1. 接收要删除的留言对象(指定 key 值)

```typescript
const { object, object_raw } = req.request.object;
// ...ignore
const decoder = new MessageDecoder();
const dr = decoder.from_raw(object_raw);
// ...ignore
const MessageObject = dr.unwrap();
```

2. 使用 PathOpEnv 根据留言对象的 key 锁定对象路径

```typescript
const queryMessagePath = `/messages_list/${MessageObject.key}`;
const paths = [queryMessagePath];
// ...ignore
const lockR = await pathOpEnv.lock(paths, cyfs.JSBI.BigInt(30000));
```

3. 使用 PathOpEnv 读取要删除的留言对象 objectId

```typescript
const idR = await pathOpEnv.get_by_path(queryMessagePath);
// ...ignore
const objectId = idR.unwrap();
// ...ignore
```

4. 使用 PathOpEnv 执行 remove_with_path 操作

```typescript
const rm = await pathOpEnv.remove_with_path(queryMessagePath, objectId);
// ...ignore
```

5. 提交事务

```typescript
const ret = await pathOpEnv.commit();
// ...ignore
```

## 查询留言

- 完整代码见 src/service/routers/retrieve_message.ts

要新增一条留言，核心是需要 5 个步骤：

1. 接收要查询的留言对象(指定 key 值)

```typescript
const { object, object_raw } = req.request.object;
// ...ignore
const decoder = new MessageDecoder();
const dr = decoder.from_raw(object_raw);
// ...ignore
const MessageObject = dr.unwrap();
```

2. 使用 PathOpEnv 根据留言对象的 key 锁定对象路径

```typescript
const queryMessagePath = `/messages_list/${MessageObject.key}`;
const paths = [queryMessagePath];
// ...ignore
const lockR = await pathOpEnv.lock(paths, cyfs.JSBI.BigInt(30000));
```

3. 使用 PathOpEnv 读取要查询的留言对象 objectId

```typescript
const idR = await pathOpEnv.get_by_path(queryMessagePath);
// ...ignore
const objectId = idR.unwrap();
// ...ignore
```

4. 在 non 上获取留言对象

```typescript
const gr = await stack.non_service().get_object({
	common: { level: cyfs.NONAPILevel.NOC, flags: 0 },
	object_id: objectId,
});
// ...ignore
```

5. 释放锁

```typescript
pathOpEnv.abort();
// ...ignore
```
======== 这篇文章可能有点长，可以考虑1分为2，运行和调试分到另一章里 ==

# 使用DEC_service暴露上述API
TODO 说明dec_service的端到端工作原理
进一步理解 CYFS的 GET,PUT,CALL系列协议语义




## 深入探究 Service 启动程序

- 完整代码见 src/service/entry/app_startup.ts

Service 启动程序的入口为 main 函数，主要完成 3 个步骤：

1. 开启 Service 日志。
2. 打开并等待 Stack 上线。
3. 在 Stack 上注册路由模块。

## 开启 Service 日志

日志可以让我们快速的发现并定位问题，对解决线上问题十分有帮助。不同的操作系统，应用日志的存储路径略有不同；

- mac: ~/Library/cyfs/log/app/<app_name>
- windows: C:\cyfs\log\app\<app_name>
- linux: /cyfs/log/app/<app_name>

基于 CYFS SDK 开启 Service 日志非常简单，代码如下：

```typescript
import * as cyfs from "cyfs-sdk";

cyfs.clog.enable_file_log({
	name: APP_NAME,
	dir: cyfs.get_app_log_dir(APP_NAME),
});
```

## 打开并等待 Stack 上线

通过引入 cyfs_helper 中的 waitStackOOD 方法，我们可以很方便实现打开并等待 Stack 上线，代码如下：

```typescript
import { waitStackOOD } from "src/common/cyfs_helper/stack_wraper";

const waitR = await waitStackOOD(DEC_ID);
if (waitR.err) {
	console.error(`service start failed when wait stack online, err: ${waitR}.`);
	return;
}
```

## 在 Stack 上注册路由

使用 addRouters 方法来批量注册路由，提高开发效率。addRouters 方法中通过遍历封装了全部路由模块的`routers`对象，完成批量注册的功能。在每一轮循环中，主要完成 2 个任务：

1. 为请求路径 req_path 动态设置 access 权限，这里我们调用 cyfs.AccessString.full 方法把该请求路径的读、写和 call 权限都打开。
2. 使用 add_post_object_handler 方法将路由模块挂载到 Stack 上的指定请求路径下。

addRouters 代码如下：

```typescript
import * as cyfs from "cyfs-sdk";

export type RouterArray = Array<{
	reqPath: string;
	router: postRouterHandle;
}>;

async function addRouters(
	stack: cyfs.SharedCyfsStack,
	routers: RouterArray
): Promise<void> {
	for (const routerObj of routers) {
		const access = new cyfs.AccessString(0);
		access.set_group_permissions(
			cyfs.AccessGroup.CurrentZone,
			cyfs.AccessPermissions.WirteAndCall
		);
		access.set_group_permissions(
			cyfs.AccessGroup.CurrentDevice,
			cyfs.AccessPermissions.WirteAndCall
		);
		access.set_group_permissions(
			cyfs.AccessGroup.OwnerDec,
			cyfs.AccessPermissions.WirteAndCall
		);
		// 打开全部权限
		// const access = cyfs.AccessString.full();
		// 为路径设置 access 权限
		const ra = await stack
			.root_state_meta_stub()
			.add_access(
				cyfs.GlobalStatePathAccessItem.new(routerObj.reqPath, access)
			);
		if (ra.err) {
			console.error(`path (${routerObj.reqPath}) add access error: ${ra}`);
			continue;
		}
		console.log("add access successed: ", ra.unwrap());
		const handleId = `post-${routerObj.reqPath}`;
		// 挂载路由模块到指定请求路径
		const r = await stack
			.router_handlers()
			.add_post_object_handler(
				cyfs.RouterHandlerChain.Handler,
				handleId,
				1,
				undefined,
				routerObj.reqPath,
				cyfs.RouterHandlerAction.Pass,
				new PostRouterReqPathRouterHandler(routerObj)
			);

		if (r.err) {
			console.error(`add post handler (${handleId}) failed, err: ${r}`);
		} else {
			console.info(`add post handler (${handleId}) success.`);
		}
	}
}
```
# 进行调试 （TODO）
我们奉行前后端分离，在这个章节里应该完成dec_service的开发并调试
用BDT协议发HTTP请求就能调试

## 在调试环境中发布服务
## 使用命令行工具查看root_state
## 用浏览器查看root_state

